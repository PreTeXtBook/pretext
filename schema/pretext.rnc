
                    grammar {
                
            start = PretextRoot | DocInfo | Part | Chapter | Section | Subsection | Subsubsection | Paragraphs | ReadingQuestions | Exercises | Subexercises |  Solutions | BookFrontMatter | ArticleFrontMatter | BookBackMatter | ArticleBackMatter | Preface | Acknowledgement | ArticleAppendix | BookAppendix | IndexDivision | References | Glossary | Figure | WebWork
            
            PretextRoot =
                element pretext {
                    XMLLang?,
                    DocInfo?,
                    (Book | Article | Letter | Memorandum)
                }
            
            Article =
                element article {
                    MetaDataLinedSubtitle,
                    ArticleFrontMatter?,
                    (
                        (
                            Objectives?,
                            (BlockDivision | Paragraphs)+,
                            (ReadingQuestions? & Exercises? &
                             Solutions? & References? & Glossary?),
                            Outcomes?
                        )
                    |
                        (
                            (Objectives? & IntroductionDivision?),
                            Section,
                            (Section | ReadingQuestions | Exercises |
                             Solutions | References | Glossary)*,
                            (Outcomes? & ConclusionDivision?),
                            ArticleBackMatter?
                        )
                    )
                }
            Book =
                ## Here is what a book looks like.
                element book {
                    MetaDataLinedSubtitle,
                    BookFrontMatter?,
                    (Part+ | Chapter+ ),
                    BookBackMatter?
                }
            Letter =
                element letter {empty}
            Memorandum =
                element memo {empty}
            
            Part =
                element part {
                    MetaDataLinedTitle, Chapter+
                }
            Chapter =
                element chapter {
                    MetaDataLinedTitle,
                    AuthorByline*,
                    (
                        (
                            Objectives?,
                            (BlockDivision | Paragraphs)+,
                            (ReadingQuestions? & Exercises? &
                             Solutions? & References? & Glossary?),
                            Outcomes?
                        )
                    |
                        (
                            (Objectives? & IntroductionDivision?),
                            Section,
                            (Section | ReadingQuestions | Exercises |
                             Solutions | References | Glossary)*,
                            (Outcomes? & ConclusionDivision?)
                        )
                    )
                }
            Section =
                element section {
                    MetaDataLinedTitle,
                    AuthorByline*,
                    (
                        (
                            Objectives?,
                            (BlockDivision | Paragraphs)+,
                            (ReadingQuestions? & Exercises? &
                             Solutions? & References? & Glossary?),
                            Outcomes?
                        )
                    |
                        (
                            (Objectives? & IntroductionDivision?),
                            Subsection,
                            (Subsection | ReadingQuestions | Exercises |
                             Solutions | References | Glossary)*,
                            (Outcomes? & ConclusionDivision?)
                        )
                    )
                }
            Subsection =
                element subsection {
                    MetaDataAltTitle,
                    AuthorByline*,
                    (
                        (
                            Objectives?,
                            (BlockDivision | Paragraphs)+,
                            (ReadingQuestions? & Exercises? &
                             Solutions? & References? & Glossary?),
                            Outcomes?
                        )
                    |
                        (
                            (Objectives? & IntroductionDivision?),
                            Subsubsection,
                            (Subsubsection | ReadingQuestions | Exercises |
                             Solutions | References | Glossary)*,
                            (Outcomes? & ConclusionDivision?)
                        )
                    )
                }
            Subsubsection =
                element subsubsection {
                    MetaDataAltTitle,
                    AuthorByline*,
                    Objectives?,
                    (BlockDivision | Paragraphs)+,
                    (ReadingQuestions? & Exercises? &
                     Solutions? & References? & Glossary?),
                    Outcomes?
                }
            ArticleAppendix =
                element appendix {
                    MetaDataAltTitle,
                    AuthorByline*,
                    (
                        (
                            Objectives?,
                            (BlockDivision | Paragraphs | NotationList)+,
                            (ReadingQuestions? & Exercises? &
                             Solutions? & References? & Glossary?),
                            Outcomes?
                        )
                    |
                        (
                            (Objectives? & IntroductionDivision?),
                            Subsection,
                            (Subsection | ReadingQuestions | Exercises |
                             Solutions | References | Glossary)*,
                            (Outcomes? & ConclusionDivision?)
                        )
                    )
                }
            BookAppendix =
                element appendix {
                    MetaDataAltTitle,
                    AuthorByline*,
                    (
                        (
                            Objectives?,
                            (BlockDivision | Paragraphs | NotationList)+,
                            (ReadingQuestions? & Exercises? &
                             Solutions? & References? & Glossary?),
                            Outcomes?
                        )
                    |
                        (
                            (Objectives? & IntroductionDivision?),
                            Section,
                            (Section | ReadingQuestions | Exercises | Solutions | References | Glossary)*,
                            (Outcomes? & ConclusionDivision?)
                        )
                    )
                }
            IndexDivision =
                element index {
                    MetaDataAltTitleOptional,
                    IndexList
                }
            
            ArticleFrontMatter =
                element frontmatter {
                    MetaDataTitleOptional,
                    Bibinfo,
                    TitlePage,
                    Abstract?
                }
            BookFrontMatter = element frontmatter {
                    MetaDataTitleOptional,
                    Bibinfo,
                    TitlePage,
                    ColophonFront?,
                    Biography*,
                    Dedication?,
                    Acknowledgement?,
                    Preface*
                }
            Bibinfo =
                element bibinfo {
                    (
                        (Author+, Editor*)
                        |
                        (Editor+)
                    )?,
                    ((Credit | ColophonCredit)* &
                    Date? &
                    Edition? &
                    Keywords* &
                    Support? &
                    Website? &
                    Copyright?)
                }
            TitlePage =
                element titlepage {
                    element titlepage-items {empty}
                }
            Email = element email {text}
            PersonName = element personname {TextSimple}
            Affiliation =
                element affiliation {
                    Department? &
                    Institution? &
                    Location?
                }
            Department = element department {TextSimple | ShortLine+}
            Institution = element institution {TextSimple | ShortLine+}
            Support = element support {TextParagraph}
            Location = element location {TextSimple | ShortLine+}
            Keywords = element keywords {
                attribute authority {text}?,
                attribute variant {text}?,
                Title?,
                Keyword+
            }
            Keyword = element keyword {
                attribute primary {"yes"|"no"}?,
                TextSimple
            }
            Edition = element edition {text}
            Event = element event {
                TextLong
            }
            Author =
                element author {
                    attribute corresponding {"yes" | "no"}?,
                    attribute xml:id {text}?,
                    PersonName,
                    (
                        (Department? & Institution? & Location?) |
                        Affiliation+
                    )?,
                    Email?,
                    Biography?,
                    Support?
                }
            Editor =
                element editor {
                    PersonName,
                    (
                        (Department? & Institution? & Location?) |
                        Affiliation+
                    )?,
                    Email?
                }
            Credit =
                element credit {
                    Title,
                    Author+
                }
            Date =
                element date {
                    mixed {(Character | Generator)*}
                }
            Abstract =
                element abstract {
                    MetaDataTarget,
                    BlockText+
                }
            ColophonCredit = element credit {
                    element role {TextShort},
                    element entity {TextLong}
                }
            ShortLicense = element shortlicense {TextLong}
            Website = element website {Url}
            Copyright =
                element copyright {
                    element year {TextShort},
                    element holder {text},
                    element minilicense {TextShort}?,
                    ShortLicense?
                }
            ColophonFront =
                element colophon {
                    MetaDataTarget,
                    element colophon-items {empty}
                }
            Biography =
                element biography {
                    MetaDataTitleOptional,
                    (BlockStatementNoCaption | ParagraphsNoNumber)+
                }
            Dedication =
                element dedication {
                    MetaDataTitleOptional,
                    (Paragraph|ParagraphLined)+
                }
            Acknowledgement =
                element acknowledgement {
                    MetaDataTitleOptional,
                    (BlockStatementNoCaption | ParagraphsNoNumber)+
                }
            Preface =
                element preface {
                    MetaDataTitleOptional,
                    (
                        (
                            (BlockStatementNoCaption | ParagraphsNoNumber)+,
                            Attribution*
                        )
                        |
                        (
                            (BlockStatementNoCaption | ParagraphsNoNumber )*,
                            Contributors,
                            (BlockStatementNoCaption | ParagraphsNoNumber)*
                        )
                    )
                }
            
            ArticleBackMatter =
                element backmatter {
                    MetaDataTitleOptional,
                    (ArticleAppendix|Solutions)*,
                    References?,
                    IndexDivision?,
                    ColophonBack?
                }
            BookBackMatter =
                element backmatter {
                    MetaDataTitleOptional,
                    (BookAppendix|Solutions)*,
                    References?,
                    IndexDivision?,
                    ColophonBack?
                }
            ColophonBack =
                element colophon {
                    MetaDataTarget,
                    (BlockText | SideBySideNoCaption | SideBySideGroupNoCaption)+
                }
            
            Paragraphs =
                element paragraphs {
                    MetaDataTitle,
                    Index*,
                    BlockDivision+
                }
            ParagraphsNoNumber =
                element paragraphs {
                    MetaDataTitle,
                    Index*,
                    BlockStatementNoCaption+
                }
            
            ReadingQuestions =
                element reading-questions {
                    MetaDataAltTitleOptional,
                    IntroductionDivision?,
                    Exercise+,
                    ConclusionDivision?
                }
            Exercises =
                element exercises {
                    MetaDataAltTitleOptional,
                    IntroductionDivision?,
                    (
                        (Exercise | ExerciseGroup)+ |
                        Subexercises+
                    ),
                    ConclusionDivision?
                }
            Subexercises =
                element subexercises {
                    MetaDataAltTitleOptional,
                    IntroductionDivision?,
                    (Exercise | ExerciseGroup)+,
                    ConclusionDivision?
                }
            Solutions =
                element solutions {
                    MetaDataAltTitleOptional,
                    attribute inline {text}?,
                    attribute divisional {text}?,
                    attribute project {text}?,
                    attribute admit {"all"|"odd"|"even"}?,
                    IntroductionDivision?,
                    ConclusionDivision?
                }
            References =
                element references {
                    MetaDataAltTitleOptional,
                    IntroductionDivision?,
                    BibliographyItem+,
                    ConclusionDivision?
                }
            Glossary =
                element glossary {
                    MetaDataAltTitleOptional,
                    HeadNote?,
                    GlossaryItem+
                }
            
            BlockText =
                Paragraph | BlockQuote | Preformatted |
                Image | Video | Program | Console | Tabular
            BlockStatementNoCaption =
                BlockText | Aside |
                SideBySideNoCaption | SideBySideGroupNoCaption
            BlockStatement =
                BlockText |
                Figure | Aside |
                SideBySide | SideBySideGroup | Sage
            BlockSolution =
                BlockStatement | Proof
            BlockDivision =
                BlockStatement |
                Remark | Computation | Theorem | Proof | Definition |
                Axiom | Example | Exercise | Project |
                Poem | Assemblage | ListGenerator | Fragment
            
            Prelude =
                element prelude {BlockText+}
            Interlude =
                element interlude {BlockText+}
            Postlude =
                element postlude {BlockText+}
            Statement =
                element statement {
                    BlockStatement+
                }
            Hint =
                element hint {
                    MetaDataTitleOptional,
                    BlockSolution+
                }
            Answer =
                element answer {
                    MetaDataTitleOptional,
                    BlockSolution+
                }
            Solution =
                element solution {
                    MetaDataTitleOptional,
                    BlockSolution+
                }
            
            IntroductionText =
                element introduction {BlockText+}
            ConclusionText =
                element conclusion {BlockText+}
            IntroductionStatementNoCaption =
                element introduction {BlockStatementNoCaption+}
            ConclusionStatementNoCaption =
                element conclusion {BlockStatementNoCaption+}
            IntroductionStatement =
                element introduction {BlockStatement+}
            ConclusionStatement =
                element conclusion {BlockStatement+}
            IntroductionDivision =
                element introduction {
                    MetaDataTitleOptional,
                    BlockDivision+
                }
            ConclusionDivision =
                element conclusion {
                    MetaDataTitleOptional?,
                    BlockDivision+
                }
            HeadNote =
                element headnote {BlockStatementNoCaption+}
            
            Objectives =
                element objectives {
                    MetaDataTitleOptional,
                    IntroductionText?,
                    List,
                    ConclusionText?
                }
            Outcomes =
                element outcomes {
                    MetaDataTitleOptional,
                    IntroductionText?,
                    List,
                    ConclusionText?
                }
            
            BlockQuote =
                element blockquote {
                    MetaDataTitleOptional,
                    Paragraph+,
                    Attribution?
                }
            SimpleLine =
                element line {TextSimple}
            ShortLine =
                element line {TextShort}
            LongLine =
                element line {TextLong}
            
            CodeLine =
                element cline {text}
            CodeDisplay =
                element cd {
                    attribute latexsep {text}?,
                    (text | CodeLine+)
                }
            Preformatted =
                element pre {
                    text | CodeLine+
                }
            ConsoleOutput =
                element output {text}
            ConsoleInput =
                element input {
                    attribute prompt {text}?,
                    attribute continuation {text}?,
                    text
                }
            Console =
                element console {
                    Component?,
                    attribute prompt {text}?,
                    attribute continuation {text}?,
                    attribute width {text}?,
                    attribute margins {text}?,
                    (
                        ConsoleInput,
                        ConsoleOutput?
                    )+
                }
            ProgramPreamble =
                element preamble {
                    attribute visible {"yes"|"no"}?,
                    text
                }
            ProgramCode = element code {text}
            ProgramPostamble =
                element postamble {
                    attribute visible {"yes"|"no"}?,
                    text
                }
            ProgramTests =
                element tests {
                    attribute visible {"yes"|"no"}?,
                    (
                        text
                    |
                        element iotest {
                            element input {text},
                            element output {text}
                        }+
                    )
                }
            ProgramStdin =
                element stdin {
                    text
                }
            Program =
                element program {
                    Component?,
                    LabelID?,
                    UniqueID?,
                    attribute width {text}?,
                    attribute margins {text}?,
                    attribute autorun {"yes"|"no"}?,
                    attribute chatcodes {"yes"|"no"}?,
                    attribute codelens {"yes"|"no"}?,
                    attribute compiler-args {text}?,
                    attribute extra-compiler-args {text}?,
                    attribute database {text}?,
                    attribute add-files {text}?,
                    attribute compile-also {text}?,
                    attribute download {"yes"|"no"}?,
                    attribute hidecode {"yes"|"no"}?,
                    attribute highlight-lines {text}?,
                    attribute include {text}?,
                    attribute filename {text}?,
                    attribute interactive {"codelens"|"activecode"}?,
                    attribute interpreter-args {text}?,
                    attribute language {text}?,
                    attribute line-numbers {"yes"|"no"}?,
                    attribute linker-args {text}?,
                    attribute timelimit {text}?,
                    (
                        text
                    |
                        (
                            ProgramPreamble?,
                            ProgramCode,
                            ProgramPostamble?,
                            ProgramTests?,
                            ProgramStdin?
                        )
                    )
                }
            
            ListItem = element li {
                (
                    (MetaDataTarget, TextParagraph)
                |
                    (MetaDataTitleOptional, BlockStatement+)
                )
            }
            DefinitionListItem = element li {
                MetaDataTitle,
                BlockStatement+
            }
            List =
                element ol {
                    Component?,
                    attribute cols {"2"|"3"|"4"|"5"|"6"}?,
                    attribute marker {text}?,
                    ListItem+
                } |
                element ul {
                    Component?,
                    attribute cols {"2"|"3"|"4"|"5"|"6"}?,
                    attribute marker {"disc" | "circle" | "square" | ""}?,
                    ListItem+
                } |
                element dl {
                    Component?,
                    attribute width {"narrow" | "medium" | "wide"}?,
                    DefinitionListItem+
                }
            
            DefinitionLike =
                MetaDataTitleOptional,
                Notation*,
                Statement
            Definition =
                element definition {DefinitionLike}
            
            Case =
                element case {
                   MetaDataTitleOptional,
                   attribute direction {text}?,
                   BlockStatement+
                   }
            Proof =
                element proof {
                    MetaDataTitleOptional,
                    (BlockStatement | Case)+
                }
            TheoremLike =
                MetaDataTitleCreatorOptional,
                (BlockStatement+ | (Statement, Proof*))
            Theorem =
                element theorem {TheoremLike} |
                element lemma {TheoremLike} |
                element corollary {TheoremLike} |
                element claim {TheoremLike} |
                element proposition {TheoremLike} |
                element algorithm {TheoremLike} |
                element fact {TheoremLike} |
                element identity {TheoremLike}
            
            AxiomLike =
                MetaDataTitleCreatorOptional,
                Statement
            Axiom =
                element axiom {AxiomLike} |
                element principle {AxiomLike} |
                element conjecture {AxiomLike} |
                element heuristic {AxiomLike} |
                element hypothesis {AxiomLike} |
                element assumption {AxiomLike}
            
            ExampleLike =
                MetaDataTitleOptional,
                (
                    (BlockStatement)+ |
                    (Statement, Hint*, Answer*, Solution*) |
                    (IntroductionStatement?, Task+, ConclusionStatement?)
                )
            Example =
                element example {ExampleLike} |
                element question {ExampleLike} |
                element problem {ExampleLike}
            
            ProjectLike =
                MetaDataTitleOptional,
                (
                    (BlockStatement+) |
                    (
                       Prelude?,
                       (
                          (Statement, Hint*, Answer*, Solution*) |
                          (IntroductionStatement?, Task+, ConclusionStatement?) |
                          (IntroductionText?, WebWork, ConclusionText?)
                       ),
                       Postlude?
                    )
                )
            Project =
                element activity {ProjectLike} |
                element investigation {ProjectLike} |
                element exploration {ProjectLike} |
                element project {ProjectLike}
            Task =
                element task {
                    MetaDataTitleOptional,
                    (
                        BlockStatement+ |
                        (Statement, Hint*, Answer*, Solution*) |
                        (IntroductionStatement?, Task+, ConclusionStatement?)
                    )
                }
            
            RemarkLike =
                MetaDataTitleOptional,
                BlockStatement+
            Remark =
                element remark {RemarkLike} |
                element convention {RemarkLike} |
                element note {RemarkLike} |
                element observation {RemarkLike} |
                element warning {RemarkLike} |
                element insight {RemarkLike}
            
            ComputationLike =
                MetaDataTitleOptional,
                BlockStatement+
            Computation =
                element computation {ComputationLike} |
                element technology {ComputationLike} |
                element data {ComputationLike}
            
            AsideLike =
                MetaDataTitleOptional,
                BlockText+
            Aside =
                element aside {AsideLike} |
                element biographical {AsideLike} |
                element historical {AsideLike}
            
            Assemblage =
                element assemblage {
                    MetaDataTitleOptional,
                    (BlockText | SideBySideNoCaption | SideBySideGroupNoCaption)+
                }
            
            Caption =
                element caption {TextLong}
            Landscape =
                attribute landscape {"yes" | "no"}
            Figure =
                element figure {
                    MetaDataCaption,
                    Landscape?,
                    (
                        Image |
                        Video |
                        SideBySide |
                        SideBySideGroup |
                        MuseScore
                    )
                } |
                element table {
                    MetaDataAltTitle,
                    Landscape?,
                    Tabular
                } |
                element listing {
                    MetaDataAltTitle,
                    Landscape?,
                    (
                        Program |
                        Console
                    )
                } |
                element list {
                    MetaDataAltTitle,
                    Landscape?,
                    IntroductionText?,
                    List,
                    ConclusionText?
                }
            
            Stack =
                element stack {
                    (
                        Tabular |
                        Image |
                        Video |
                        Program |
                        Console |
                        Paragraph |
                        Preformatted |
                        List
                    )+
                }
            SidebySideAttributes =
                Component?,
                attribute margins {text}?,
                (attribute width {text} | attribute widths {text})?,
                (AlignmentVertical | attribute valigns {text})?
            SideBySide =
                element sidebyside {
                    SidebySideAttributes,
                    (
                        Figure |
                        Poem |
                        Tabular |
                        Image |
                        Video |
                        Program |
                        Console |
                        Paragraph |
                        Preformatted |
                        List |
                        Stack
                    )+
                }
            SideBySideNoCaption =
                element sidebyside {
                    SidebySideAttributes,
                    (
                        Poem |
                        Tabular |
                        Image |
                        Video |
                        Program |
                        Console |
                        Paragraph |
                        Preformatted |
                        List |
                        Stack
                    )+
                }
            SideBySideGroup =
                element sbsgroup {
                    SidebySideAttributes,
                    SideBySide+
                }
            SideBySideGroupNoCaption =
                element sbsgroup {
                    SidebySideAttributes,
                    SideBySideNoCaption+
                }
            
            Image = ImageRaster | ImageCode
            ImageDescription = element description {(Paragraph | Tabular)+}
            ImageShortDescription = element shortdescription {text}
            ImageShortDescriptionCode = element shortdescription {
                (text | WWVariable)+
            }
            ImageRaster =
                element image {
                    UniqueID?,
                    Component?,
                    attribute width {text}?,
                    attribute margins {text}?,
                    attribute rotate {text}?,
                    attribute archive {text}?,
                    attribute source {text},
                    (
                      attribute decorative {"yes"} |
                      (
                        attribute decorative {"no"}?,
                        (
                          ImageShortDescription? &
                          ImageDescription?
                        )
                      )
                    )
                }
            CodeLatexImage =
                element latex-image {
                    LabelID?,
                    Component?,
                    text
                }
            ImageCode =
                element image {
                    UniqueID?,
                    Component?,
                    attribute width {text}?,
                    attribute margins {text}?,
                    attribute archive {text}?,
                    (
                      attribute decorative {"yes"} |
                      (
                        attribute decorative {"no"}?,
                        (
                          ImageShortDescriptionCode ? &
                          ImageDescription? &
                          (
                            CodeLatexImage |
                            element asymptote {
                              LabelID?,
                              Component?,
                              text
                            } |
                            element sageplot {
                                LabelID?,
                                Component?,
                                attribute variant {'2d'|'3d'}?,
                                attribute aspect {text}?,
                                text
                            }
                          )
                        )
                      )
                    )
                }
            WWLatexImage = element latex-image {
                text
              }
            ImageWW =
                element image {
                    attribute pg-name {text}?,
                    attribute width {text}?,
                    (
                      attribute decorative {"yes"} |
                      (
                        attribute decorative {"no"}?,
                        (
                          ImageShortDescriptionCode? &
                          ImageDescription? &
                          WWLatexImage?
                        )
                      )
                    )
                }
            
            BorderThickness = "none" | "minor" | "medium" | "major"
            BorderTop =
                attribute top {BorderThickness}
            BorderBottom =
                attribute bottom {BorderThickness}
            BorderLeft =
                attribute left {BorderThickness}
            BorderRight =
                attribute right {BorderThickness}
            AlignmentHorizontal =
                attribute halign {"left" | "center" | "right" | "justify"}
            AlignmentVertical =
                attribute valign {"top" | "middle" | "bottom"}

            TableCell =
                element cell {
                    AlignmentHorizontal?,
                    BorderBottom?,
                    BorderRight?,
                    attribute colspan {text}?,
                    (
                        TextLong |
                        LongLine+ |
                        Paragraph+
                    )
                }
            TableRow =
                element row {
                    attribute header {"yes" | "no" | "vertical"}?,
                    AlignmentHorizontal?,
                    AlignmentVertical?,
                    BorderBottom?,
                    BorderLeft?,
                    TableCell+
                }
            TableColumn =
                element col {
                    AlignmentHorizontal?,
                    BorderTop?,
                    BorderRight?,
                    attribute width {text}?
                }
            Tabular =
                element tabular {
                    Component?,
                    attribute width {text}?,
                    attribute margins {text}?,
                    attribute row-headers {"yes" | "no"}?,
                    AlignmentHorizontal?,
                    AlignmentVertical?,
                    BorderTop?,
                    BorderBottom?,
                    BorderLeft?,
                    BorderRight?,
                    TableColumn*,
                    TableRow+
                }
            
            SageOutput = element output {text}
            SageInput = element input {text}
            Sage = element sage {
                Component?,
                attribute doctest {text}?,
                attribute tolerance {text}?,
                attribute auto-evaluate {'no'|'yes'}?,
                attribute language {text}?,
                attribute type {text}?,
                (SageInput, SageOutput?)?
            }
            
            MuseScore =
                element score {
                    attribute musescoreuser {text},
                    attribute musescore {text}
                }
            
            Video =
                element video {
                    UniqueID?,
                    LabelID?,
                    Component?,
                    attribute width {text}?,
                    attribute margins {text}?,
                    attribute aspect {text}?,
                    attribute start {xsd:integer}?,
                    attribute end {xsd:integer}?,
                    attribute play-at {"embed" | "popout" | "select"}?,
                    attribute preview {"default" | "generic" | text}?,
                    (AttributesSourceFile | AttributesNetwork | AttributesYouTube |
                     AttributesYouTubePlaylist | AttributesVimeo)
                }
            AttributesSourceFile =
                attribute source {text}
            AttributesNetwork =
                attribute href {text}
            AttributesYouTube =
                attribute youtube {text}
            AttributesYouTubePlaylist =
                attribute youtubeplaylist {text}
            AttributesVimeo =
                attribute vimeo {text}
            
            ExerciseOrderedList =
                element ol {
                    attribute cols {text}?,
                    attribute marker {text}?,
                    ExerciseListItem+
                }
            ExerciseListItem = element li {
                MetaDataTarget,
                (TextParagraph | BlockText+)
            }
            ExerciseBody =
                (
                    BlockStatement |
                    ExerciseOrderedList
                )+
            StatementExercise =
                element statement { ExerciseBody }
            Exercise =
                element exercise {
                    MetaDataTitleOptional,
                    attribute number {text}?,
                    (
                    ExerciseBody |
                    (StatementExercise, Hint*, Answer*, Solution*) |
                    (IntroductionStatement?, Task+, ConclusionStatement?) |
                    (IntroductionText?, WebWork, ConclusionText?)
                    )
                }
            ExerciseGroup =
                element exercisegroup {
                    MetaDataTitleOptional,
                    attribute cols {"2"|"3"|"4"|"5"|"6"}?,
                    IntroductionStatementNoCaption,
                    Exercise+,
                    ConclusionStatementNoCaption?
                }
            
            AlignmentPoem = attribute halign {"left" | "center" | "right"}
            PoemAuthor =
                element author {
                    AlignmentPoem?,
                    TextShort
                }
            Poem =
                element poem {
                    MetaDataTitleOptional,
                    AlignmentPoem?,
                    PoemAuthor?,
                    (PoemLine+ | Stanza+)
                }
            Stanza =
                element stanza {
                    MetaDataTitleOptional,
                    PoemLine+
                }
            PoemLine =
                element line {
                    attribute indent {xsd:integer}?,
                    TextShort
                }
            
            TextBib = mixed { (Character | MathInline)* }
            BibliographyItem =
                element biblio {
                    MetaDataTarget,
                    ((
                        attribute type {"raw"},
                        (TextLong |
                        Ibid |
                        BibTitle |
                        BibYear |
                        BibJournal |
                        BibNumber |
                        BibVolume |
                        BibNote)*
                    ) |
                    (
                        attribute type {"bibtex"},
                        (BibTitle |
                        BibAuthor |
                        BibEditor |
                        BibYear |
                        BibJournal |
                        BibNumber |
                        BibVolume |
                        BibSeries |
                        BibPublisher |
                        BibPages |
                        BibNote)*
                    ))
                }
            Ibid = element ibid {empty}
            BibYear = element year {text}
            BibJournal = element journal { TextBib }
            BibNumber = element number {text}
            BibVolume = element volume {text}
            BibTitle = element title {TextLong}
            BibNote = element note {UniqueID?, Paragraph+}
            BibAuthor = element author {text}
            BibEditor = element editor {text}
            BibSeries = element series {text}
            BibPublisher = element publisher {text}
            BibPages = element pages {
                (
                    attribute start {text},
                    attribute end {text},
                    empty
                ) |
                (
                    text
                )
                }
            
            GlossaryItem =
                element gi {
                    MetaDataTitle,
                    BlockStatementNoCaption+
                }
            
            Contributor =
                element contributor {
                    MetaDataTarget,
                    PersonName,
                    (
                        (
                        Department?,
                        Institution?,
                        Location?
                        )
                        |
                        Affiliation+
                    )?,
                    Email?
                }
            Contributors =
                element contributors {
                    Contributor+
                }
            AuthorByline =
                element author {(TextSimple|Xref)}
            
            WebWork = (WebWorkAuthored | WebWorkSource)
            WebWorkSource =
                element webwork {
                    attribute source {text}?,
                    attribute seed {xsd:integer}?
                }
            WWDescription =
                element description {
                    (
                        TextSimple |
                        SimpleLine+
                    )
                }
            WebWorkAuthored =
                element webwork {
                    (
                        UniqueID?,
                        LabelID?,
                        Component?,
                        attribute seed {xsd:integer}?,
                        attribute copy {text}?,
                        WWDescription?,
                        WWMacros?,
                        element pg-code {text}?,
                        (
                            (StatementExerciseWW, HintWW?, SolutionWW?)
                        |
                            (IntroductionText?, TaskWW+, ConclusionText?)
                        )
                    ) |
                    text
                }
            BlockStatementWW =
                        Paragraph |
                        Preformatted |
                        Tabular |
                        ImageWW
            StatementExerciseWW =
                element statement {
                    (BlockStatementWW|WWInstruction)+
                }
            TaskWW =
                element task {
                    MetaDataTitleOptional,
                    (
                        (StatementExerciseWW, HintWW?, SolutionWW?) |
                        (IntroductionText?, TaskWW+, ConclusionText?)
                    )
                }
            WWMacros =
                element pg-macros {
                    element macro-file {text}+
                }
            WWVariable =
                ## The WeBWorK "var" element appears in the RELAX-NG schema as a child of many elements, but almost always as a descendant of a "p" element or a "cell" element.  As an element that is only relevant for a WeBWorK problem, occurrences of "var" must be within a "webwork" element.  A Schematron rule will check on these two situations.
                element var {
                    (attribute name {text},
                    attribute evaluator {text}?,
                    attribute width {text}?,
                    attribute category {
                                        "angle" | "decimal" | "exponent"
                                      | "formula" | "fraction" | "inequality"
                                      | "integer" | "interval" | "logarithm"
                                      | "limit" | "number" | "point"
                                      | "syntax" | "quantity" | "vector"
                                      }?,
                    attribute form {"popup"|"buttons"|"checkboxes"|"none"}?) |
                    (attribute form {"essay"},
                    attribute width {text}?)
                }
            WWInstruction =
                element instruction {TextShort}
            HintWW =
                element hint {
                    (BlockStatementWW)+
                }
            SolutionWW =
                element solution {
                    (BlockStatementWW)+
                }
            
            Fragment =
                element fragment {
                    (
                        attribute xml:id {text}
                    |
                        (
                            attribute filename {text},
                            attribute xml:id {text}?
                         )
                    ),
                    Title,
                    (
                        element code {text} |
                        element fragref {
                            attribute ref {text}
                        }
                    )+
                }
            
            
            Attribution =
                element attribution {
                    (TextLong | LongLine+)
                }
            
            UniqueID =
                attribute xml:id {text}
            LabelID =
                attribute label {text}
            Component =
                attribute component {text}
            Title =
                element title {TextLong}
            LinedTitle =
                element title {LongLine+}
            Subtitle =
                element subtitle {TextLong}
            LinedSubtitle =
                element subtitle {LongLine+}
            ShortTitle =
                element shorttitle {TextShort}
            PlainTitle =
                element plaintitle {text}
            Creator =
                element creator {TextShort}
            XMLBase = attribute xml:base {text}
            XMLLang = attribute xml:lang {text}
            MetaDataTarget =
                UniqueID?,
                LabelID?,
                Component?,
                Index*
            MetaDataTitle =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                Title,
                Index*
            MetaDataAltTitle =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                Title,
                ShortTitle?,
                PlainTitle?,
                Index*
            MetaDataLinedTitle =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                (Title | LinedTitle),
                ShortTitle?,
                PlainTitle?,
                Index*
            MetaDataSubtitle =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                Title,
                Subtitle?,
                ShortTitle?,
                PlainTitle?,
                Index*
            MetaDataLinedSubtitle =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                (Title | LinedTitle),
                (Subtitle | LinedSubtitle)?,
                ShortTitle?,
                PlainTitle?,
                Index*
            MetaDataTitleOptional =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                Title?,
                Index*
            MetaDataAltTitleOptional =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                (Title, ShortTitle?, PlainTitle?)?,
                Index*
            MetaDataTitleCreatorOptional =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                Title?,
                Creator?,
                Index*
            MetaDataCaption =
                UniqueID?,
                LabelID?,
                Component?,
                XMLBase?,
                XMLLang?,
                Title?,
                Caption,
                Index*
            
            TextParagraph = mixed { (
                Character |
                Generator |
                Verbatim |
                Group |
                WWVariable |
                MathInline |
                Music |
                Reference |
                CodeDisplay |
                MathDisplay |
                List |
                Footnote |
                Notation |
                Index)* }
            Paragraph =
                element p {
                    UniqueID?,
                    LabelID?,
                    Component?,
                    TextParagraph
                }
            ParagraphLined =
                element p {
                    UniqueID?,
                    LabelID?,
                    Component?,
                    element line {TextShort}+
                }
            
            TextSimple = mixed {
                Character* }
            TextShort = mixed { (
                Character |
                Generator |
                Verbatim |
                Group |
                MathInline |
                Music)* }
            TextLong =  mixed { (
                Character |
                Generator |
                Verbatim |
                Group |
                MathInline |
                Music |
                Reference |
                WWVariable)* }
                
            Footnote =
                element fn {
                    MetaDataTarget,
                    TextLong
                }
            
            IdxHeading =
                element h {
                    attribute sortby {text}?,
                    TextShort
                }
            Index =
                element idx {
                    MetaDataTarget,
                    attribute sortby {text}?,
                    attribute start {text}?,
                    attribute finish {text}?,
                    (
                        TextShort
                    |
                        (
                        IdxHeading,
                        IdxHeading?,
                        IdxHeading?,
                        (element see {TextShort} | element seealso {TextShort})?
                        )
                    )
                }
            IndexList = element index-list {empty}
            
            XrefTextStyle =
                "local" | "global" | "hybrid" | "type-local" | "type-global" |
                "type-hybrid" | "phrase-global" | "phrase-hybrid" |
                "title" | "custom"
            Reference = Url | Xref
            Url =
                element url {
                    attribute href {text},
                    attribute visual {text}?,
                    TextShort?
                }
            Xref =
                element xref {
                        (
                            attribute ref {text} |
                            (attribute first {text}, attribute last {text}) |
                            attribute provisional {text}
                        ),
                        attribute text { XrefTextStyle }?,
                        attribute detail {text}?,
                        TextShort
                }
            NotationDescription =
                element description {
                    TextShort
                }
            Notation =
                element notation {
                    element usage {MathInline},
                    NotationDescription
                }
            
            FillInMath = element fillin {
                             (attribute fill{text}?|attribute characters {xsd:integer}?),
                             empty
                         }
            MathInline =
                element m {
                    mixed {(FillInMath | WWVariable)*}
                }
            MathRow =
                element mrow {
                    MetaDataTarget,
                    (
                        attribute number {"yes" | "no"} |
                        attribute tag {"star" | "dstar" | "tstar" |
                                       "dagger" | "ddagger" | "tdagger" |
                                       "daggerdbl" | "ddaggerdbl" | "tdaggerdbl" |
                                       "hash" | "dhash" | "thash" |
                                       "maltese" | "dmaltese" | "tmaltese" }
                    )?,
                    attribute break {"yes" | "no"}?,
                    mixed {(Xref | FillInMath | WWVariable)*}
                }
            MathIntertext = element intertext {TextLong}
            MathDisplay =
                element me {
                    mixed {(FillInMath | WWVariable)*}
                } |
                element men {
                    MetaDataTarget,
                    mixed {(FillInMath | WWVariable)*}
                } |
                element md {
                    attribute number {"yes" | "no"}?,
                    attribute break {"yes" | "no"}?,
                    attribute alignment {text}?,
                    attribute alignat-columns {text}?,
                    MathRow,
                    (MathRow | MathIntertext)*
                } |
                element mdn {
                    attribute number {"yes" | "no"}?,
                    attribute break {"yes" | "no"}?,
                    attribute alignment {text}?,
                    attribute alignat-columns {text}?,
                    MathRow,
                    (MathRow | MathIntertext)*
                }
            
            Verbatim =
                element c {text} |
                Email |
                element pf {
                    attribute language {text}?,
                    text
                }
            
            Group |=
                element abbr {TextSimple} |
                element acro {TextSimple} |
                element init {TextSimple}
            
            Group |=
                element q {TextLong} |
                element sq {TextLong} |
                element angles {TextLong} |
                element dblbrackets {TextLong}
                
            Group |=
                element em {TextLong} |
                element term {TextLong} |
                element alert {TextLong} |
                element pubtitle {TextLong} |
                element articletitle {TextLong} |
                element foreign {
                  XMLLang?,
                  TextLong
                }
            
            Group |=
                element delete {TextLong} |
                element insert {TextLong} |
                element stale {TextLong}
                
            Group |=
                element tag {text} |
                element tage {text} |
                element attr {text}
            
            Group |=
                element taxon {
                    attribute ncbi {xsd:integer}?,
                    (
                        text |
                        (
                            element genus {text}?,
                            element species {text}?
                        )
                    )
                }
            
            Generator =
                element today {empty} |
                element timeofday {empty} |
                element tex {empty} |
                element latex {empty} |
                element xetex {empty} |
                element xelatex {empty} |
                element pretext {empty} |
                element prefigure {empty} |
                element webwork {empty} |
                element ad {empty} |
                element am {empty} |
                element bc {empty} |
                element ca {empty} |
                element eg {empty} |
                element etal {empty} |
                element etc {empty} |
                element ie {empty} |
                element nb {empty} |
                element pm {empty} |
                element ps {empty} |
                element vs {empty} |
                element viz {empty}
            
            FillInText =
                element fillin {
                    attribute characters {xsd:integer}?,
                    attribute rows {xsd:integer}?,
                    attribute cols {xsd:integer}?,
                    empty
                }
            Generator |=
                FillInText
            
            UnitSpecification =
                    attribute prefix {text}?,
                    attribute base {text},
                    attribute exp {xsd:integer}?
            Generator |=
                element quantity {
                    element mag {text}?,
                    element unit {UnitSpecification}*,
                    element per {UnitSpecification}*
                }
            
            Character |=
                element nbsp {empty} |
                element ndash {empty} |
                element mdash {empty}
            
            Character =
                element lsq {empty} |
                element rsq {empty} |
                element rq {empty} |
                element lq {empty} |
                element ldblbracket {empty} |
                element rdblbracket {empty} |
                element langle {empty}|
                element rangle {empty}
            
            Character |=
                element minus {empty} |
                element times {empty} |
                element solidus {empty} |
                element obelus {empty} |
                element plusminus {empty} |
                element degree {empty} |
                element prime {empty} |
                element dblprime {empty}
            
            CopyrightCharacter =
                element copyright {empty}
            Character |=
                element ellipsis {empty} |
                element midpoint {empty} |
                element swungdash {empty} |
                element permille {empty} |
                element pilcrow {empty} |
                element section-mark {empty} |
                element copyleft {empty} |
                CopyrightCharacter |
                element registered {empty} |
                element trademark {empty} |
                element phonomark {empty} |
                element servicemark {empty}
            
            Character |=
                element icon {
                    attribute name {text}
                }
                
            Character |=
                element kbd {
                    (text | attribute name {text})
                }
            
            MusicFlat =
                element flat {empty}
            MusicSharp =
                element sharp {empty}
            Music =
                element doublesharp {empty} |
                MusicSharp |
                element natural {empty} |
                MusicFlat |
                element doubleflat {empty} |
                element scaledeg {"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|"10"} |
                element timesignature {
                    attribute top {text},
                    attribute bottom {text}
                } |
                element n {
                    attribute pc {
                        "A"|"B"|"C"|"D"|"E"|"F"|"G"|"a"|"b"|"c"|"d"|"e"|"f"|"g"|
                        "1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|"10"
                    },
                    attribute acc {"doublesharp"|"sharp"|"flat"|"doubleflat"}?,
                    attribute octave {"1"|"2"|"3"|"4"|"5"}?
                } |
                element chord {
                    attribute root {text}?,
                    attribute mode {text}?,
                    attribute bps {text}?,
                    attribute bass {text}?,
                    attribute suspended {"yes"|"no"}?,
                    attribute parentheses {"yes"|"no"}?,
                    element alteration {
                        (TextSimple |
                        MusicSharp |
                        MusicFlat)*
                    }*
                }
                
            ListGenerator =
                element list-of {
                    attribute elements {text},
                    attribute scope {text}?,
                    attribute divisions {text}?,
                    attribute empty {"yes" | "no"}?
                }
            NotationList =
                element notation-list {empty}
            
            DocInfo =
                element docinfo {
                    XMLBase?,
                    XMLLang?,
                    Configuration+
                }
            
            Configuration |=
                element brandlogo {
                    attribute url {text}?,
                    attribute source {text}
                }
            
            Configuration |=
                    element math-package {
                        attribute latex-name {text},
                        attribute mathjax-name {text}
                    }*
            Configuration |=
                element latex-image-preamble {text}
            Configuration |=
                element asymptote-preamble {text}
            
            Configuration |=
                element macros {text}
            
            Configuration |=
                element
                    cross-references {
                        attribute text { XrefTextStyle }
                    }
            
            Configuration |=
                element initialism {text}
            
            FeedbackUrl = element url {text}
            Configuration |=
                element feedback {
                    FeedbackUrl
                }
            
            Configuration |=
                element rename {
                    attribute element {text},
                    attribute xml:lang {text}?,
                    text
                }
            
            Configuration |=
                element images {
                    element archive {
                        attribute from {text}?,
                        text
                    }+
                }
            
            Configuration |=
                element author-biographies {
                    attribute length {"short" | "long"}
                }
            
            Configuration |=
                element numbering {
                    element division {
                        attribute part {"decorative" | "structural"}
                    }?
                }
            
            Configuration |=
                element programs {
                    attribute language {text}?,
                    attribute compiler-args {text}?,
                    attribute download {"yes"|"no"}?,
                    attribute linenumbers {"yes"|"no"}?,
                    attribute linker-args {text}?,
                    attribute interpreter-args {text}?,
                    attribute timeout {text}?
                }
            
            Configuration |=
                element parsons {
                    attribute language {text}?
                }
            
                    }
                