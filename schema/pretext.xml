<?xml version="1.0" encoding="UTF-8" ?>

<!--   = one, mandatory -->
<!-- ? = one, optional  -->
<!-- * = zero or more   -->
<!-- + = one or more    -->

<pretext>

    <docinfo>
        <cross-references text="type-global" />
    </docinfo>

    <article xml:id="pretext">
        <title>PreTeXt RELAX-NG Schema</title>

        <!-- necessary to get title to appear/ -->
        <frontmatter>
            <p>Junk</p>
        </frontmatter>

    <introduction>
        <p>This is a literate programming version of the <init>RELAX-NG</init> schema for <pretext/>.  As such, it is used to generate the <init>RELAX-NG</init> compact syntax version (<c>pretext.rnc</c>) and other versions are derived from the compact version with standard tools.</p>

        <p>We intend this to be helpful, for both authors and developers.  It is essentially a contract between the two.  If an author's source validates against the schema, then a developer's code should render the content accurately, or warn about why it cannot.  That said, it is still a work in progress.<ul>
            <li>New features are not added until they are reasonably stable.  Validating the sample article can be a good way to see what these are.</li>
            <li>Even for stable features, the schema will sometimes lag behind the code.</li>
            <li>There will be other inaccuracies here, so reports or pull requests are welcome.</li>
        </ul></p>

        <p>The <init>RELAX-NG</init> syntax is built on <term>patterns</term>, which describe how <init>XML</init> elements and attributes may be combined.  It begins with a <c>start</c> pattern.  Patterns separated by commas must appear in that order.  Elements separated by a vertical bar represent a choice.  Parentheses are used for grouping.  Braces are basic syntax, reminiscent of the syntax for Java.  An equals sign is assignment and <c>|=</c> is a continuation of an assignment.  Finally, optional and/or multiple occurences can be specified with modifiers:<dl>
            <li>
                <title><c>?</c></title>
                <p>Zero or one.  Optional, at most one.</p>
            </li>
            <li>
                <title><c>*</c></title>
                <p>Zero or more.  Optional, with no limit.</p>
            </li>
            <li>
                <title><c>+</c></title>
                <p>One or more.  Required, with no limit.</p>
            </li>
        </dl></p>
    </introduction>

    <section>
        <title>Gross Structure</title>

        <p>A <pretext/> document is always a single <c>mathbook</c> element below the root.  There are two divisions, a <c>docinfo</c>, which is a database of sorts about the document, along with a sibling element that indicates the type of the document and contains all the content.  (2019-02-08:  the root element may be <tag>pretext</tag>, and eventually <tag>mathbook</tag> will be deprecated.)</p>

        <fragment xml:id="gross-structure">
        start =
            element pretext {
                XMLLang?,
                DocInfo?,
                (Book | Article | Letter | Memorandum)
            }
        </fragment>
    </section>

    <section>
        <title>Document Types</title>

        <p><c>letter</c> and <c>memo</c> elements are not documented.</p>

        <fragment xml:id="document-types">
        Article =
            element article {
                MetaDataLinedSubtitle,
                ArticleFrontMatter?,
                (
                    (
                        (BlockDivision | Paragraphs | Commentary)+,
                        Exercises?,
                        Solutions?,
                        References?
                    )
                |
                    (
                        IntroductionDivision?,
                        Section+,
                        Exercises*,
                        ConclusionDivision?,
                        ArticleBackMatter?
                    )
                )
            }
        Book =
            ## Here is what a book looks like.
            element book {
                MetaDataLinedSubtitle,
                BookFrontMatter?,
                (Part+ | Chapter+ ),
                BookBackMatter?
            }
        Letter =
            element letter {empty}
        Memorandum =
            element memo {empty}
        </fragment>
    </section>

    <section>
        <title>Document Structure</title>

        <p>A document is typically divided into sections.  But we reserve the word <c>section</c> for one very specific type of division.  To avoid confusion, we speak generically of <term>divisions</term>.  So, for example, a <c>section</c> is a division of a <c>chapter</c>.  Here we list all of the possible divisions, even if they are not available in each document type.</p>

        <p>An <c>appendix</c> looks like a chapter of a <c>book</c>, with the option to have a <c>notation-list</c> or a <c>solution-list</c> as its entire contents.  It is possible this is not the best structure for an <c>article</c>, which might best be divided by <c>subsection</c>.</p>

        <p>There are several things to note (expand this): always a title, dead-end with blocks, or subdivide with optional intro and conclusion.</p>

        <fragment xml:id="divisions">
        Part =
            element part {
                MetaDataLinedTitle, Chapter+
            }
        Chapter =
            element chapter {
                MetaDataLinedTitle,
                AuthorByline*,
                Objectives?,
                (
                    (
                        (BlockDivision | Paragraphs | Commentary)+,
                        Exercises?,
                        Solutions?,
                        References?
                    )
                |
                    (
                        IntroductionDivision?,
                        Section+,
                        Exercises*,
                        Solutions?,
                        References?,
                        ConclusionDivision?
                    )
                ),
                Outcomes?
            }
        Section =
            element section {
                MetaDataLinedTitle,
                AuthorByline*,
                Objectives?,
                (
                    (
                        (BlockDivision | Paragraphs | Commentary)+,
                        Exercises?,
                        Solutions?,
                        References?
                    )
                |
                    (
                        IntroductionDivision?,
                        Subsection+,
                        Exercises*,
                        Solutions?,
                        References?,
                        ConclusionDivision?
                    )
                ),
                Outcomes?
            }
        Subsection =
            element subsection {
                MetaDataShortTitle,
                AuthorByline*,
                Objectives?,
                (
                    (
                        (BlockDivision | Paragraphs | Commentary)+,
                        Exercises?,
                        Solutions?,
                        References?
                    )
                |
                    (
                        IntroductionDivision?,
                        Subsubsection+,
                        Exercises*,
                        Solutions?,
                        References?,
                        ConclusionDivision?
                    )
                ),
                Outcomes?
            }
        Subsubsection =
            element subsubsection {
                MetaDataShortTitle,
                AuthorByline*,
                Objectives?,
                (BlockDivision | Paragraphs | Commentary)+,
                Exercises?,
                Solutions?,
                References?,
                Outcomes?
            }
        ArticleAppendix =
            element appendix {
                MetaDataShortTitle,
                AuthorByline*,
                (
                    (BlockDivision | Paragraphs | Commentary | NotationList )+ |
                    (
                        IntroductionDivision?,
                        Subsection,
                        (
                            Subsection |
                            Exercises |
                            References
                        )*,
                        ConclusionDivision?
                    )
                )
            }
        BookAppendix =
            element appendix {
                MetaDataShortTitle,
                AuthorByline*,
                (
                    (BlockDivision | Paragraphs | Commentary | NotationList )+ |
                    (
                        IntroductionDivision?,
                        Section,
                        (
                            Section |
                            Exercises |
                            References
                        )*,
                        ConclusionDivision?
                    )
                )
            }
        IndexDivision =
            element index {
                MetaDataShortTitleOptional,
                IndexList
            }
        </fragment>
    </section>


    <section>
        <title>Lightweight Divisions</title>

        <p>The <c>paragraphs</c> element, which is not to be confused with a <em>real</em> paragraph as implemented by the <c>p</c> element, is an exceptional type of division (both in design and utility).  It must have a <c>title</c>, can appear anywhere within any of the divisions, cannot be further subdivided, and is not ever numbered.  Its contents are conceptually a run of paragraphs, but as described here allow much more than that.</p>

        <p>It is especially useful in a short document (like a class handout, letter, memorandum, or short proposal) where numbered divisions might feel like overkill.</p>

        <p>The <c>NoNumber</c> variant allows for light-weight sectioning of un-numbered divisions, such as a Preface.</p>

        <p><tag>commentary</tag> is elective, so should not have any numbered items ever, so the <q>NoNumber</q> provision is implicit.</p>

        <fragment xml:id="paragraphs">
        Paragraphs =
            element paragraphs {
                MetaDataTitle,
                Index*,
                BlockDivision+
            }
        ParagraphsNoNumber =
            element paragraphs {
                MetaDataTitle,
                Index*,
                BlockStatementNoCaption+
            }
        Commentary =
            element commentary {
                MetaDataTitle,
                Index*,
                BlockStatementNoCaption+
            }
        </fragment>
    </section>

    <section>
        <title>Universal Divisions</title>

        <p>We add specialized divisions, which may appear within any of the above divisions.  Titles will be provided as defaults.</p>

        <fragment xml:id="universal">
        Exercises =
            element exercises {
                MetaDataShortTitleOptional,
                IntroductionDivision?,
                (Exercise | ExerciseGroup)+,
                ConclusionDivision?
            }
        Solutions =
            element solutions {
                MetaDataShortTitleOptional,
                attribute inline {text}?,
                attribute divisional {text}?,
                attribute project {text}?,
                IntroductionDivision?,
                ConclusionDivision?
            }
        References =
            element references {
                MetaDataShortTitleOptional,
                IntroductionDivision?,
                BibliographyItem+,
                ConclusionDivision?
            }
        </fragment>
    </section>


    <section>
        <title>Paragraphs</title>

        <p>Most <pretext /> elements are about delineating structure.  What you actually write happens in very few places.  Principally paragraphs, but also titles, captions, index headings, and other short bursts.  The shorter the burst, the more likely the text will be recycled in other places (Table of Contents, List of Figures, or Index perhaps).  And the more text gets re-purposed, the more care we need to take with its contents.</p>

        <p><term>Simple text</term> is simply runs of characters, some of which is accomplished with empty elements.  This is used for names of people, <etc />  It should not be confused with the RELAX-NG keyword <c>text</c> which matches runs of (Unicode) characters, with no intervening markup.  So the latter is used for things like <init>URL</init>s, internal identifiers, configuration parameters, and so on.</p>

        <p><term>Short text</term> is used for titles, subtitles, names, index headings, and so on.  It allows a variety of characters, font styling, groupings, and convenience constructions.  It does not allow for references, nor anything that typographically requires more than the linearity of a sentence.  In other words, no lists, no images, no tables, no displayed equations.  Because of the potential for movement, we also do not include footnotes within short text.</p>

        <p><term>Long text</term> is everything that is short text, but also allows for references, both external (internet <init>URL</init>s) and internal (cross-references).  It is used for the content of footnotes and captions.  The <webwork /> variant allows for variables in inline mathematics.</p>

        <fragment xml:id="shorttext">
        TextSimple = mixed {
            Character* }
        TextShort = mixed { (
            Character |
            Generator |
            Verbatim |
            Group |
            MathInline |
            Music)* }
        TextLong =  mixed { (
            Character |
            Generator |
            Verbatim |
            Group |
            MathInline |
            Music |
            Reference |
            WWVariable)* }
        </fragment>

        <p>A paragraph is a key bottleneck between structure and prose.  You can use a variety of constructs in a paragraph, and you may use a paragraph in many places.  So the name of the element is very simple, just a <c>p</c>.  Now you can include footnotes, display mathematics, display verbatim text, and lists.  Note that a list can <em>only</em> occur in a paragraph, so to make nested lists you must structure a list item of the exterior list with a paragraph to contain the interior list.  A paragraph can contain some metadata, like index entries and mathematical notation.  It does not have a title, not is it ever numbered.  It can be the target of a cross-reference, but only with some care.</p>

        <p>A <term>lined paragraph</term> is a variant, for use when the line-by-line structure is necessary.  The <webwork /> variant of a <c>p</c> element allows for using the <c>var</c> element as an answer blank or generated content, possibly inside mathematics, and possibly inside lists.</p>

        <p>Note: A paragraph effectively could have the <c>MetaDataTarget</c> pattern, except that we allow index elements (<tag>idx</tag>) to go anywhere within the paragraph.</p>

        <fragment xml:id="paragraph">
        TextParagraph = mixed { (
            Character |
            Generator |
            Verbatim |
            Group |
            WWVariable |
            MathInline |
            Music |
            Reference |
            CodeDisplay |
            MathDisplay |
            List |
            Footnote |
            Notation |
            Index)* }
        Paragraph =
            element p {
                UniqueID?,
                PermanentID?,
                TextParagraph
            }
        ParagraphLined =
            element p {
                UniqueID?,
                PermanentID?,
                element line {TextShort}+
            }
        </fragment>

        <p>Fundamentally <pretext /> allows for conversion to other markup languages, such as <latex /> or <init>HTML</init>, and of course <init>XML</init> is a syntax for designing a markup vocabulary.  As such, certain characters traditionally found on keyboards have been co-opted for special purposes.  And once you actually want one of those special characters, you need an escape character to indicate a <q>normal</q> use.  For these reasons, certain characters have empty elements to represent them.</p>

        <p>Special characters for <init>XML</init> are the ampersand, less than, greater than, single quote and double quote: <c>&amp;</c>, <c>&lt;</c>, <c>&gt;</c>, <c>'</c>, <c>"</c>.  The ampersand is the escape character for <init>XML</init>.  In practice, the first two characters are the most important, since processing of your <init>XML</init> will be confused by any attempt to use them directly.  So in regular text (not mathematics, not verbatim), always use the the escaped versions:  <c>&amp;amp;</c>, <c>&amp;lt;</c>, and perhaps <c>&amp;gt;</c>.</p>

        <p>See below for elements that can be used to form groupings with left and right delimiters.  For example, a simple quotation should use a left double quote and a right double quote, and these characters should look different (so-called <term>smart</term> quotes).  Notice that a keyboard only has a single <term>dumb</term> quote.  If you need these characters in isolation (<ie />, not in pairs), these are the best way to ensure you get what you want in all possible conversions.  Note that left and right braces (<q>curly brackets</q>) are previously defined with the <latex /> characters.</p>

        <fragment xml:id="delimiter-character">
        Character =
            element lsq {empty} |
            element rsq {empty} |
            element rq {empty} |
            element lq {empty}
        </fragment>

        <p>A space is a space.  But sometimes you want a space between two associated items which will not get split across two lines (<eg/>, Chapter<nbsp />23).  An element will create a <term>non-breaking space</term> using the right technique for the conversion at hand.</p>

        <p>There is a variety of dashes of various lengths.  Use the keyboard character for a <term>hyphen</term>, use an <term>ndash</term> to seperate a range of numbers or dates, and use an <term>mdash</term> as punctuation within a sentence to isolate a clause.  These are implemented differently for different conversions, so their use is strongly encouraged.</p>

        <fragment xml:id="dash-character">
        Character |=
            element nbsp {empty} |
            element ndash {empty} |
            element mdash {empty}
        </fragment>

        <p>A <c>fillin</c> blank is not really a character, but maybe a really long, low dash?  The <c>characters</c> attribute controls the length.  It is atomic, indivisable, and content-less, like all the other characters.  <c>fillin</c> is also unusual due to its allowed use within mathematics.</p>

        <fragment xml:id="fillin-character">
        FillIn = element fillin {attribute characters {xsd:integer}?, empty}
        Character |=
            FillIn
        </fragment>

        <p>We define a few characters to help with simple expressions in arithmetic.  The <term>solidus</term> is slightly different from the <term>slash</term> found on a keyboard and is used for fractions and ratios.  These are for simple uses in regular text, not for actual mathematics, which is described later.</p>

        <fragment xml:id="arithmetic-character">
        Character |=
            element solidus {empty} |
            element times {empty}
        </fragment>

        <p>The following are largely conveniences.  They are typically not available on keyboards, and their implementations for various conversions can involve some subtleties.  Again, their use is encouraged for the best quality output.</p>

        <fragment xml:id="exotic-character">
        Character |=
            element ellipsis {empty} |
            element midpoint {empty} |
            element swungdash {empty} |
            element permille {empty} |
            element pilcrow {empty} |
            element section-mark {empty} |
            element copyright {empty} |
            element registered {empty} |
            element trademark {empty}
        </fragment>

        <p>Icons are available through a <attr>name</attr> attribute, which is meant to usually be more semantic than just a description of the picture, though that may sometimes be the case.  These are intended for use when describing elements of computer interfaces.  Icons which are decorative shuld be supplied as part of styling, not as part of the source language.</p>

        <fragment xml:id="icon-character">
        Character |=
            element icon {
                attribute name {text}
            }
        </fragment>

        <p>We support musical notation as if they were characters: accidentals, scale degrees, notes, and chords.  Implementation of these is about as complicated as inline mathematical notation, hence they have identical rules about placement.</p>

        <fragment xml:id="music-character">
        Music =
            element doublesharp {empty} |
            element sharp {empty} |
            element natural {empty} |
            element flat {empty} |
            element doubleflat {empty} |
            element scaledeg {"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|"10"} |
            element timesignature {
                attribute top {text},
                attribute bottom {text}
            } |
            element n {
                attribute pc {
                    "A"|"B"|"C"|"D"|"E"|"F"|"G"|"a"|"b"|"c"|"d"|"e"|"f"|"g"|
                    "1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"|"10"
                },
                attribute acc {"doublesharp"|"sharp"|"flat"|"doubleflat"}?,
                attribute octave {"1"|"2"|"3"|"4"|"5"}?
            } |
            element chord {
                attribute root {text}?,
                attribute mode {text}?,
                attribute bps {text}?,
                attribute bass {text}?,
                attribute suspended {"yes"|"no"}?,
                attribute parentheses {"yes"|"no"}?,
                element alteration {
                    (TextSimple |
                    element sharp {empty} |
                    element flat {empty})*
                }*
            }
        </fragment>

        <fragment xml:id="character">
            <fragment ref="dash-character" />
            <fragment ref="fillin-character" />
            <fragment ref="delimiter-character" />
            <fragment ref="arithmetic-character" />
            <fragment ref="exotic-character" />
            <fragment ref="icon-character" />
            <fragment ref="music-character" />
        </fragment>

        <p>There are empty elements to generate certain items, like the date, or names of commonly referenced tools, such as <pretext /> itself.  These include some common <term>Latin abbreviations</term>, for the purpose of handling the periods properly in conversions to <latex />.</p>

        <!-- webwork, latex will need work -->
        <fragment xml:id="generator">
        Generator =
            element today {empty} |
            element timeofday {empty} |
            element tex {empty} |
            element latex {empty} |
            element pretext {empty} |
            element webwork {empty} |
            element ad {empty} |
            element am {empty} |
            element bc {empty} |
            element ca {empty} |
            element eg {empty} |
            element etal {empty} |
            element etc {empty} |
            element ie {empty} |
            element nb {empty} |
            element pm {empty} |
            element ps {empty} |
            element vs {empty} |
            element viz {empty}
        </fragment>

        <p>A large class of similary indivisible items are units on physical quantities.  The <tag>quantity</tag> element is allowed to be empty, and the code should silently produce no output.  Expressing non-emptieness here might get a bit messy, so a Schematron warning could be a good alternative.</p>

        <fragment xml:id="siunit">
        UnitSpecification =
                attribute prefix {text}?,
                attribute base {text},
                attribute exp {xsd:integer}?
        Generator |=
            element quantity {
                element mag {text}?,
                element unit {UnitSpecification}*,
                element per {UnitSpecification}*
            }
        </fragment>

        <p>Some markup is for just ASCII characters, in other words, unadorned verbatim text.</p>

        <fragment xml:id="verbatim">
        Verbatim =
            element c {text} |
            element email {text}
        </fragment>

        <p>Simple markup is groupings of text that gets a different typographic appearance, either through font changes or through delimiters.  Examples are emphasis or paired quotations, non-examples are cross-references or footnotes.</p>

        <p>Abbreviations are sequences of characters that shorten some longer word or words (<eg /> <abbr>vs.</abbr> for the Latin <foreign>versus</foreign>), initialisms are formed from the first letters of a sequence of words (<eg /> <init>HTML</init>), acronyms are pronouncable as words (<eg /> <acro>SCUBA</acro>).</p>

        <fragment xml:id="abbreviation-group">
        Group |=
            element abbr {TextSimple} |
            element acro {TextSimple} |
            element init {TextSimple}
        </fragment>

        <p>Notice that long text can be part of a grouping construction, and that long text can can contain a group construction.  The effect is that these groupings can be nested arbitrarily deep.</p>

        <fragment xml:id="delimiter-group">
        Group |=
            element q {TextLong} |
            element sq {TextLong} |
            element angles {TextLong} |
            element dblbrackets {TextLong}
        </fragment>

        <fragment xml:id="highlight-group">
        Group |=
            element em {TextLong} |
            element term {TextLong} |
            element alert {TextLong} |
            element pubtitle {TextLong} |
            element articletitle {TextLong} |
            element foreign {
              XMLLang?,
              TextLong
            }
        </fragment>

        <fragment xml:id="editing-group">
        Group |=
            element delete {TextLong} |
            element insert {TextLong} |
            element stale {TextLong}
        </fragment>

        <p>We use elements to get consistent typography when discussing <pretext /> itself.  We could probably limit the content of these elements to lowercase letters and a hyphen.  The definitions here will preclude any contained markup.</p>

        <fragment xml:id="xml-syntax-group">
        Group |=
            element tag {text} |
            element tage {text} |
            element attr {text}
        </fragment>

        <p>An empty <c>taxon</c> will match either version.</p>

        <fragment xml:id="scientific-name-group">
        Group |=
            element taxon {
                attribute ncbi {xsd:integer}?,
                (
                    TextSimple |
                    (
                        element genus {TextSimple}?,
                        element species {TextSimple}?
                    )
                )
            }
        </fragment>

        <fragment xml:id="group">
            <fragment ref="abbreviation-group" />
            <fragment ref="delimiter-group" />
            <fragment ref="highlight-group" />
            <fragment ref="editing-group" />
            <fragment ref="xml-syntax-group" />
            <fragment ref="scientific-name-group" />
        </fragment>
    </section>

    <section>
        <title>Mathematics</title>

        <p>All mathematics appears inside paragraphs, and the syntax is that of <latex />, as supported by MathJax, whose supported commands and macros are meant to be very similar to those of the AMSMath package.  Note that the content is typically unstructured, excepting <q>fill-in-the-blank</q>, <webwork /> variables (see variants), and internal cross-references in multi-row display mathematics. Also, <c>md</c> and <c>mdn</c> are not targets of cross-references, though their rows can be.</p>

        <fragment xml:id="mathematics">
        MathInline =
            element m {
                mixed {(FillIn | WWVariable)*}
            }
        MathRow =
            element mrow {
                MetaDataTarget,
                (
                    attribute number {"yes" | "no"}
                    |
                    attribute tag {"star" | "dstar" | "tstar" |
                                   "dagger" | "ddagger" | "tdagger" |
                                   "hash" | "dhash" | "thash" |
                                   "maltese" | "dmaltese" | "tmaltese" }
                )?,
                attribute break {"yes" | "no"}?,
                mixed {(Xref | FillIn | WWVariable)*}
            }
        MathIntertext = element intertext {TextLong}
        MathDisplay =
            element me {
                mixed {(FillIn | WWVariable)*}
            }
        |
            element men {
                MetaDataTarget,
                mixed {(FillIn | WWVariable)*}
            }
        |
            element md {
                attribute number {"yes" | "no"}?,
                attribute break {"yes" | "no"}?,
                attribute alignment {text}?,
                attribute alignat-columns {text}?,
                MathRow,
                (MathRow | MathIntertext)*
            }
        |
            element mdn {
                attribute number {"yes" | "no"}?,
                attribute break {"yes" | "no"}?,
                attribute alignment {text}?,
                attribute alignat-columns {text}?,
                MathRow,
                (MathRow | MathIntertext)*
            }
        </fragment>
    </section>


    <section>
        <title>Blocks</title>

        <p>A <term>text block</term> is very similar to a paragraph.  It can be an actual paragraph, a sequence of paragraphs enclosed as a block quote (with attribution, perhaps), or a large chunk of unformatted text presented typically in a monospace font.</p>

        <p>A <term>statement block</term> is used in statements.  What are those?  Theorems have statements, exercises have statements, questions have statements.  Some of these blocks with statements also have proofs, hints, and solutions.  In statements, and their peers, we include text blocks, captioned items, asides, side-by-side layouts, and Sage computations, but exclude many of the numbered and titled division blocks.  The <c>NoCaption</c> variant prohibits all numbered items, but allows placement of items like <c>image</c>.  It also does not include <c>Sage</c>.</p>

        <p>A <term>division block</term> includes text blocks, statement blocks, plus topical chunks of text that can have numbered headings or numbered captions, with optional titles, and are set apart slightly from the surrounding narrative.  These are placed mostly as children of divisions, and so one cannot contain another.  They certainly contain paragraphs, and all that goes into them, such as mathematics (inline and display) and figures (and other captioned items).  The <c>sidebyside</c> element can be used to illustrate a division block with a variety of images and displayed text in flexible layouts.</p>

        <p>Other division blocks include <c>poem</c>, <c>aside</c>, and <c>assemblage</c>.  These are never numbered, but can have titles.  The <c>list-of</c> mechanism is a convenience device to automatically create lists of contents, and so we leave surrounding divisional structure to the author.  A <c>sidebyside</c>, and its cousin, <c>sbsgroup</c>, are strictly layout devices.  The <c>sage</c> element is unique for its possibilities in certain electronic formats.</p>

        <p><c>demonstration</c> is slated for removal or an overhaul, and so is in the <xref ref="badbank" text="title" />.  Avoid using them for now.</p>

        <fragment xml:id="block">
        BlockText =
            Paragraph | BlockQuote | Preformatted
        BlockStatementNoCaption =
            BlockText | Aside |
            SideBySideNoCaption | SideBySideGroupNoCaption
        BlockStatement =
            BlockText |
            Figure | Aside |
            SideBySide | SideBySideGroup | Sage
        BlockDivision =
            BlockStatement |
            Remark | Computation | Theorem | Proof | Definition |
            Axiom | Example | Exercise | Project |
            Poem | Assemblage | ListGenerator |
            Demonstration
        </fragment>

        <p>Blocks are often structured, in a light way.  Hints, answers, and solutions adorn exercises, examples, and projects.  A simple introduction or conclusion is sometimes useful.  A <c>prelude</c> or <c>postlude</c> are authored inside a block and so are associated with it.  But they are presented before and after the block visually.  An <c>interlude</c> will be used between the statment of a theorem and its proof.</p>

        <p>When a block is structured to allow some of the ancillary parts, a <c>statement</c> element is used to structure the main part.  Hints, answers, and solutions can be the target of cross-references, but do not get author-supplied titles.</p>

        <fragment xml:id="block-component">
        Prelude =
            element prelude {BlockText+}
        Interlude =
            element interlude {BlockText+}
        Postlude =
            element postlude {BlockText+}
        Statement =
            element statement {
                BlockStatement+
            }
        Hint =
            element hint {
                MetaDataTitleOptional,
                BlockStatement+
            }
        Answer =
            element answer {
                MetaDataTitleOptional,
                BlockStatement+
            }
        Solution =
            element solution {
                MetaDataTitleOptional,
                BlockStatement+
            }
        </fragment>
    </section>

    <section>
        <title>Introductions and Conclusions</title>

        <p>The <c>introduction</c> and <c>conclusion</c> containers can be used in a variety of other structured elements.  They come in three levels, according to what they can contain, and are meant to be consonant with their surroundings.  As children of a division, they may carry a <c>title</c>, which in turn allows them to be cross-referenced by that text.</p>

        <fragment xml:id="introduction-conclusion">
        IntroductionText =
            element introduction {BlockText+}
        ConclusionText =
            element conclusion {BlockText+}
        IntroductionStatementNoCaption =
            element introduction {BlockStatementNoCaption+}
        ConclusionStatementNoCaption =
            element conclusion {BlockStatementNoCaption+}
        IntroductionStatement =
            element introduction {BlockStatement+}
        ConclusionStatement =
            element conclusion {BlockStatement+}
        IntroductionDivision =
            element introduction {
                MetaDataTitleOptional,
                BlockDivision+
            }
        ConclusionDivision =
            element conclusion {
                MetaDataTitleOptional?,
                BlockDivision+
            }
        </fragment>
    </section>

    <section>
        <title>References</title>

        <p>There are a variety of referencing mechanisms, external references, internal cross-references, index entries, and specialized support for a table of mathematical notation.</p>

        <fragment xml:id="reference">
        XrefTextStyle =
            "local" | "global" | "hybrid" | "type-local" | "type-global" |
            "type-hybrid" | "phrase-global" | "phrase-hybrid" | "title"
        Reference = Url | Xref
        Url =
            element url {
                attribute href {text},
                TextShort
            }
        Xref =
            element xref {
                    (
                        attribute ref {text} |
                        (attribute first {text}, attribute last {text}) |
                        attribute provisional {text}
                    ),
                    attribute text { XrefTextStyle }?,
                    attribute detail {text}?,
                    TextShort
            }
        Notation =
            element notation {
                element usage {text},
                element description {
                    TextShort
                }
            }
        </fragment>

        <p>Footnotes are especially dangerous.  They should contain quite a bit of content, and should be targets of cross-references.  So the content is not as expansive as a regular paragraph, which is possibly too restrictive.</p>

        <fragment xml:id="footnote">
            Footnote =
                element fn {
                    MetaDataTarget,
                    TextLong
                }
        </fragment>

        <p>Index entries have two forms, simple and structured.  The <c>start</c> and <c>finish</c> attributes are meant to use <c>xml:id</c> to create an index range that crosses <init>XML</init> boundaries.  (Replace principal tags with <c>idx/h/h</c>.)</p>

        <p>The actual index is generated within the <c>index-part</c> via the <c>index-list</c> element.</p>

        <p>Note that we might point to another index entry as part of a <q>see also</q> mechanism.</p>

        <fragment xml:id="index">
        IdxHeading =
            element h {
                attribute sortby {text}?,
                TextShort
            }
        Index =
            element idx {
                MetaDataTarget,
                attribute sortby {text}?,
                attribute start {text}?,
                attribute finish {text}?,
                (
                    TextShort
                |
                    (
                    IdxHeading,
                    IdxHeading?,
                    IdxHeading?,
                    (element see {TextShort} | element seealso {TextShort})?
                    )
                )
            }
        IndexList = element index-list {empty}
        </fragment>

    </section>

    <section>
        <title>Objectives</title>

        <p>A division may lead (first) with an optional list of objectives for the division and may be followed by a (final) optional list of outcomes.  The element names are only chosen to reflect a pre- and post- behavior and so could be used for objectivbes, outcomes, and standards in a variety of ways.</p>

        <fragment xml:id="objective-outcome">
        Objectives =
            element objectives {
                MetaDataTitleOptional,
                IntroductionText?,
                List,
                ConclusionText?
            }
        Outcomes =
            element outcomes {
                MetaDataTitleOptional,
                IntroductionText?,
                List,
                ConclusionText?
            }
        </fragment>
    </section>

    <section>
        <title>Block Quotes</title>

        <p>These are a run of paragraphs, but may optionally have an <c>attribution</c>.</p>

        <fragment xml:id="blockquote">
        BlockQuote =
            element blockquote {
                MetaDataTitleOptional,
                Paragraph+,
                Attribution?
            }
        ShortLine =
            element line {TextShort}
        LongLine =
            element line {TextLong}
        </fragment>
    </section>

    <section>
        <title>Verbatim Text</title>

        <p>Large blocks of verbatim material, rather than just little bits in a sentence.  A code display, <c>cd</c>, is an analog of a math display, and meant to be used <em>within</em> a paragraph, either as a single line of text, or optionally structured as several lines by using code lines, <c>cline</c>.   <c>pre</c> is a block, which preserves line breaks and sanitizes whitespace to the left.  It can be optionally structured as code lines.  It should be thought of as a monospace analogue of a <q>regular</q> paragraph, minus indentation and automatic line-breaking.</p>

        <fragment xml:id="verbatimdisplay">
        CodeLine =
            element cline {text}
        CodeDisplay =
            element cd {
                attribute latexsep {text}?,
                (text | CodeLine+)
            }
        Preformatted =
            element pre {
                text | CodeLine+
            }
        Console =
            element console {
                PermanentID?,
                (
                    element prompt {text}?,
                    element input {text}?,
                    element output {text}?
                )+
            }
        Program =
            element program {
                PermanentID?,
                attribute language {text}?,
                attribute interactive {"pythontutor"}?,
                element input {text}
            }
        </fragment>
    </section>

    <section>
        <title>Lists</title>

        <p>Are complicated.  Maybe we need a special type of paragraph which does not allow nesting a description list down into some other list?</p>

        <p>As a container, the lists themselves get no metadata.  But the numbered or titled list items do get metadata.  To point to an entire list, make it a <term>named list</term> and point to that.</p>

        <fragment xml:id="list">
        List =
            element ol {
                PermanentID?,
                attribute cols {"2"|"3"|"4"|"5"|"6"}?,
                attribute label {text}?,
                element li {
                    MetaDataTarget,
                    (TextParagraph | BlockStatement+)
                }+
            }
        |
            element ul {
                PermanentID?,
                attribute cols {"2"|"3"|"4"|"5"|"6"}?,
                attribute label {"disc" | "circle" | "square" | ""}?,
                element li {
                    PermanentID?,
                    (TextParagraph | BlockStatement+)
                }+
            }
        |
            element dl {
                PermanentID?,
                attribute width {"narrow" | "medium" | "wide"}?,
                element li {
                    MetaDataTitle,
                    BlockStatement+
                }+
            }
        </fragment>
    </section>

    <section>
        <title>Definitions</title>

        <p>Definitions are special, there is nothing else quite like them.  A statement, no proof, and also a natural place for notation entries.</p>

        <fragment xml:id="definition-like">
        DefinitionLike =
            MetaDataTitleOptional,
            Notation*,
            Statement
        Definition =
            element definition {DefinitionLike}
        </fragment>
    </section>

    <section>
        <title>Theorems, And Other Results</title>

        <p>Theorems, corollaries, lemmas <mdash /> they all have statements, and should have proof(s).  Otherwise they are all the same.  A proof may be divided with cases, in no particular rigid way, just as a marker of any number of different, non-overlapping portions of a proof.  Titles can be used to describe each case, or implication arrows may be used (typically with a prrof of an equivalence).  A <c>proof</c> is also allowed to stand on its own as a block, independent of a structure like a <c>theorem</c> or <c>algorithm</c>.</p>

        <fragment xml:id="theorem-like">
        Case =
            element case {
               MetaDataTitleOptional,
               attribute direction {text}?,
               BlockStatement+
               }
        Proof =
            element proof {
                MetaDataTitleOptional,
                (BlockStatement | Case)+
            }
        TheoremLike =
            MetaDataTitleCreatorOptional,
            (BlockStatement+ | (Statement, Proof*))
        Theorem =
            element theorem {TheoremLike}
        |
            element lemma {TheoremLike}
        |
            element corollary {TheoremLike}
        |
            element claim {TheoremLike}
        |
            element proposition {TheoremLike}
        |
            element algorithm {TheoremLike}
        |
            element fact {TheoremLike}
        |
            element identity {TheoremLike}
        </fragment>
    </section>

    <section>
        <title>Axioms and Other Mathematical Statements</title>

        <p>Mathematical statements that do not have proofs (in other words, no proof is known, or a proof is not appropriate).</p>

        <fragment xml:id="axiom-like">
        AxiomLike =
            MetaDataTitleCreatorOptional,
            Statement
        Axiom =
            element axiom {AxiomLike}
        |
            element principle {AxiomLike}
        |
            element conjecture {AxiomLike}
        |
            element heuristic {AxiomLike}
        |
            element hypothesis {AxiomLike}
        |
            element assumption {AxiomLike}
        </fragment>
    </section>

    <section>
        <title>Projects and Activities</title>

        <p>A favorite of Inquiry-Based Learning textbooks.  Numbered independently.  Possibly structured with <c>task</c>.  Three different ways to structure this, we combine the second two so that the derived XML Schema (XSD) version is less-confusing to certain tools (<eg/> the Red Hat XML schema validator used within VS Code).</p>

        <fragment xml:id="project-like">
        ProjectLike =
            MetaDataTitleOptional,
            (
                (BlockStatement+) |
                (
                   Prelude?,
                   (
                      (Statement, Hint*, Answer*, Solution*) |
                      (IntroductionStatement?, Task+, ConclusionStatement?)
                   ),
                   Postlude?
                )
            )
        Project =
            element activity {ProjectLike}
        |
            element investigation {ProjectLike}
        |
            element exploration {ProjectLike}
        |
            element project {ProjectLike}
        Task =
            element task {
                MetaDataTarget,
                (
                    BlockStatement+ |
                    (Statement, Hint*, Answer*, Solution*) |
                    (IntroductionStatement?, Task+, ConclusionStatement?)
                )
            }
        </fragment>
    </section>

    <section>
        <title>Remarks and Other Comments</title>

        <p>Really simple blocks, they do not have much structure, and so are just runs of paragraphs.</p>

        <fragment xml:id="remark-like">
        RemarkLike =
            MetaDataTitleOptional,
            BlockText+
        Remark =
            element remark {RemarkLike}
        |
            element convention {RemarkLike}
        |
            element note {RemarkLike}
        |
            element observation {RemarkLike}
        |
            element warning {RemarkLike}
        |
            element insight {RemarkLike}
        </fragment>
    </section>

    <section>
        <title>Computations and Technology</title>

        <p>Somewhat simple blocks, they do not have much structure, but can hold more than a Remark.</p>

        <fragment xml:id="computation-like">
        ComputationLike =
            MetaDataTitleOptional,
            BlockStatement+
        Computation =
            element computation {ComputationLike}
        |
            element technology {ComputationLike}
        </fragment>
    </section>

    <section>
        <title>Asides</title>

        <p>An aside is a deviation from the narrative, and might physically move in the presentation (say, to a margin, or to a knowl).  <c>biographical</c> and <c>historical</c> may be further developed.</p>

        <fragment xml:id="aside">
        AsideLike =
            MetaDataTitleOptional,
            BlockStatement+
        Aside =
            element aside {AsideLike}
            |
            element biographical {AsideLike}
            |
            element historical {AsideLike}
        </fragment>
    </section>

    <section>
        <title>Assemblages</title>

        <p>Since an <c>assemblage</c> is meant to accumulate significant content (as a review or summary, or for initial presentation) lists are allowed here, an exception to their restriction to paragraphs.  We are also mildly restrictive about what can be content here<mdash />in particular blocks are excluded, despite not strictly being blocks themselves.</p>

        <fragment xml:id="assemblage">
        Assemblage =
            element assemblage {
                MetaDataTitleOptional,
                (BlockText | SideBySideNoCaption | SideBySideGroupNoCaption)+
            }
        </fragment>
    </section>

    <section>
        <title>Figures, Tables, Listings and Named Lists</title>

        <p>These are containers that carry titles, captions, and numbers and need to be filled with other (indivisable) items.  They have a mandatory <c>caption</c> (which can have no text, but will still produce a numbered caption), and may have a <c>title</c>, which could more appropriately be called a <term>heading</term>.  These are also called <term>captioned items</term>.</p>

        <fragment xml:id="table-figure">
        Caption =
            element caption {TextLong}
        Figure =
            element figure {
                MetaDataCaption,
                (
                    Image |
                    SideBySide |
                    SideBySideGroup |
                    Video |
                    MuseScore
                )
            }
        |
            element table {
                MetaDataCaption,
                Tabular
            }
        |
            element listing {
                MetaDataCaption,
                (
                    Program |
                    Console
                )
            }
        |
            element list {
                MetaDataCaption,
                IntroductionText?,
                List,
                ConclusionText?
            }
        </fragment>

        <p>The guts of a table go in a <c>tabular</c> element.</p>

        <fragment xml:id="tabular">
        BorderThickness = "none" | "minor" | "medium" | "major"
        BorderTop =
            attribute top {BorderThickness}
        BorderBottom =
            attribute bottom {BorderThickness}
        BorderLeft =
            attribute left {BorderThickness}
        BorderRight =
            attribute right {BorderThickness}
        AlignmentHorizontal =
            attribute halign {"left" | "center" | "right" | "justify"}
        AlignmentVertical =
            attribute valign {"top" | "middle" | "bottom"}

        TableCell =
            element cell {
                AlignmentHorizontal?,
                BorderBottom?,
                BorderRight?,
                attribute colspan {text}?,
                (
                    TextLong |
                    LongLine+ |
                    Paragraph+
                )
            }
        TableRow =
            element row {
                AlignmentHorizontal?,
                AlignmentVertical?,
                BorderBottom?,
                BorderLeft?,
                TableCell+
            }
        TableColumn =
            element col {
                AlignmentHorizontal?,
                BorderTop?,
                BorderRight?,
                attribute width {text}?
            }
        Tabular =
            element tabular {
                PermanentID?,
                AlignmentHorizontal?,
                AlignmentVertical?,
                BorderTop?,
                BorderBottom?,
                BorderLeft?,
                BorderRight?,
                TableColumn*,
                TableRow+
            }
        </fragment>
    </section>

    <section>
        <title>Side-By-Side Layout</title>

        <p>Page width or screen width, both are at a premium.  Height goes on forever (barring physical page breaks) and we have many devices for demarcating that flow.  But sometimes you need to organize items horizontally, <ie /> side-by-side.  We place the components of a <c>sidebyside</c> into generic regions of specified width called <term>panels</term>.</p>

        <p>This is a pure layout device.  So you cannot title it, nor caption it.  It does not admit a <c>xml:id</c> attribute, since you cannot make it the target of a cross-reference.  Nor can you reference it from the index (but you can point to its surroundings from the index).</p>

        <p>Because of its utility, it can go anywhere a block can go (<ie />, as a child of a division) and it can go many other places as a sibling of a paragraph (such as to illustrate an <c>example</c>).</p>

        <p>Note that widths give on a <c>sidebyside</c> override any width given to the components of the panels.</p>

        <p>A <tag>stack</tag> allows non-captioned, non-titled elements to accumulate vertically in a single panel.  It is a basic container.</p>

        <p>A group of side-by-sides is designed to stack vertically with common controls on widths, etc.  Its implementation is entirely experimental right now, even if we are relatively confident of the markup.</p>

        <p>For <webwork /> the NoCaption variant allows <c>Tabular</c> and <c>ImageWW</c>.  This may change if these two items are liberated from <tag>sidebyside</tag>.  Presently, there should only be a single item inside a <c>sidebyside</c> inside a <c>webwork</c>, but we do not have a rule for that.</p>

        <fragment xml:id="sidebyside">
        Stack =
            element stack {
                (
                    Tabular |
                    Image |
                    Video |
                    Program |
                    Console |
                    Paragraph |
                    Preformatted |
                    List
                )+
            }
        SidebySideAttributes =
            PermanentID?,
            attribute margins {text}?,
            (attribute width {text} | attribute widths {text})?,
            (AlignmentVertical | attribute valigns {text})?
        SideBySide =
            element sidebyside {
                SidebySideAttributes,
                (
                    Figure |
                    Poem |
                    Tabular |
                    Image |
                    Video |
                    Program |
                    Console |
                    Paragraph |
                    Preformatted |
                    List |
                    Stack
                )+
            }
        SideBySideNoCaption =
            element sidebyside {
                SidebySideAttributes,
                (
                    Poem |
                    Tabular |
                    Image |
                    ImageWW |
                    Video |
                    Program |
                    Console |
                    Paragraph |
                    Preformatted |
                    List |
                    Stack
                )+
            }
        SideBySideGroup =
            element sbsgroup {
                SidebySideAttributes,
                SideBySide+
            }
        SideBySideGroupNoCaption =
            element sbsgroup {
                SidebySideAttributes,
                SideBySideNoCaption+
            }
        </fragment>
    </section>

    <section>
        <title>Images and Graphics</title>

        <p>Raster, and described by languages, plus 100% duplicates.  The <webwork /> variant is quite different.</p>

        <p>Note: the <c>ImageCode</c> pattern allows an <attr>xml:id</attr> attribute since it is used to construct a filename.</p>

        <fragment xml:id="image">
        Image = ImageRaster | ImageCode
        ImageRaster =
            element image {
                PermanentID?,
                attribute width {text}?,
                attribute archive {text}?,
                element description {TextShort}?,
                attribute source {text}
            }
        ImageCode =
            element image {
                UniqueID?,
                PermanentID?,
                attribute width {text}?,
                attribute archive {text}?,
                element description {TextShort}?,
                (
                    element latex-image {text} |
                    element asymptote {text} |
                    element sageplot {text}
                )
            }
        ImageWW =
            element image {
                attribute pg-name {text}?,
                element description {(TextShort | WWVariable)*}?
            }
        </fragment>
    </section>

    <section>
        <title>Sage Code</title>

        <p>Sage is integral.</p>

        <fragment xml:id="sage">
        Sage = element sage {
            PermanentID?,
            attribute doctest {text}?,
            attribute tolerance {text}?,
            attribute language {text}?,
            attribute type {text}?,
            (element input {text}, element output {text}?)?
        }
        </fragment>
    </section>

    <section>
        <title>Interactive Elements</title>

        <p>Some specific interactive goodies.  These are being phased-out in favor of a more general <tag>interactive</tag> element.</p>

        <fragment xml:id="interactive">
        MuseScore =
            element score {
                attribute musescoreuser {text},
                attribute musescore {text}
            }
        </fragment>
    </section>

    <section>
        <title>Audio and Video</title>

        <p>Well, just video right now.  The <c>xml:id</c> is not used as a target, but rather as a name for a static preview image that is auto-generated by the <c>mbx</c> script thumbnail file, hence optional.  <c>preview</c> maybe be one of two reserved switches, or the filename of a static preview image.</p>

        <p>Note: the <c>Video</c> pattern allows an <attr>xml:id</attr> attribute since it is used to construct a filename for preview images (<q>poster</q>), especially when scraped.</p>


        <fragment xml:id="audiovideo">
        Video =
            element video {
                UniqueID?,
                PermanentID?,
                attribute width {text}?,
                attribute aspect {text}?,
                attribute start {xsd:integer}?,
                attribute end {xsd:integer}?,
                attribute play-at {"embed" | "popout" | "select"}?,
                attribute preview {"default" | "generic" | text}?,
                (AttributesSourceFile | AttributesYouTube | AttributesYouTubePlaylist)
            }
        AttributesSourceFile =
            attribute source {text}
        AttributesYouTube =
            attribute youtube {text}
        AttributesYouTubePlaylist =
            attribute youtubeplaylist {text}
        </fragment>
    </section>

    <section>
        <title>Poetry</title>

        <p>Poems!</p>

        <fragment xml:id="poetry">
        AlignmentPoem = attribute halign {"left" | "center" | "right"}
        Poem =
            element poem {
                MetaDataTitleOptional,
                AlignmentPoem?,
                element author {
                    AlignmentPoem?,
                    TextShort
                }?,
                (PoemLine+ | Stanza+)
            }
        Stanza =
            element stanza {
                MetaDataTitleOptional,
                PoemLine+
            }
        PoemLine =
            element line {
                attribute indent {xsd:integer}?,
                TextShort
            }
        </fragment>
    </section>

    <section>
        <title>Exercises</title>

        <p>Inline, divisional, and <webwork />.  Exercises use ordered lists for parts of their statement (something that may need to be revisited).</p>



        <fragment xml:id="exercise">
        ExerciseBody =
            (
                BlockStatement |
                element ol {
                    attribute cols {text}?,
                    attribute label {text}?,
                    element li {
                        MetaDataTarget,
                        (TextParagraph | BlockText+)
                    }+
                }
            )+
        StatementExercise =
            element statement { ExerciseBody }
        Exercise =
            element exercise {
                MetaDataTitleOptional,
                attribute number {text}?,
                (
                ExerciseBody |
                (StatementExercise, Hint*, Answer*, Solution*) |
                (IntroductionText?, WebWork, ConclusionText?)
                )
            }
        ExerciseGroup =
            element exercisegroup {
                MetaDataTitleOptional,
                attribute cols {"2"|"3"|"4"|"5"|"6"}?,
                IntroductionStatementNoCaption?,
                Exercise+,
                ConclusionStatementNoCaption?
            }
        </fragment>
    </section>

    <section>
        <title>Bibliography</title>

        <p>This is all stop-gap and will change radically.  But it seems to work for now.</p>

        <fragment xml:id="bibliography">
        BibliographyItem =
            element biblio {
                MetaDataTarget,
                attribute type {"raw"}?,
                (TextLong |
                Ibid |
                BibTitle |
                BibYear |
                BibJournal |
                BibNumber |
                BibVolume |
                BibNote)*
            }
        Ibid = element ibid {empty}
        BibYear = element year {text}
        BibJournal = element journal {text}
        BibNumber = element number {text}
        BibVolume = element volume {text}
        BibTitle = element title {TextLong}
        BibNote = element note {UniqueID?, Paragraph+}
        </fragment>
    </section>

    <section>
        <title>Examples and Questions</title>

        <p>Expository, but with solutions, etc. (Borrows from exercises.)</p>

        <fragment xml:id="example-like">
        ExampleLike =
            MetaDataTitleOptional,
            ((BlockStatement)+ | (Statement, Hint*, Answer*, Solution*))
        Example =
            element example {ExampleLike}
        |
            element question {ExampleLike}
        |
            element problem {ExampleLike}
        </fragment>
    </section>

    <section>
        <title><webwork /> Exercises</title>

        <p>Modified versions of various aspects to allow authoring <webwork /> exercises.</p>

        <p>Notes:<ul>
            <li>Statements, hints and solutions do not require at least one paragraph, so may be just a table or figure (say).</li>
            <li>Are static and set elements mutually exclusive?</li>
            <li>Can the usage part of the var element be split across math and paragraphs?</li>
        </ul></p>.


        <fragment xml:id="webwork">
        WebWork = (WebWorkAuthored | WebWorkSource)
        WebWorkSource =
            element webwork {
                attribute source {text}?,
                attribute seed {xsd:integer}?
            }
        WebWorkAuthored =
            element webwork {
                MetaDataTitleOptional,
                attribute seed {xsd:integer}?,
                WWMacros?,
                WWSetup?,
                (
                    (StatementExerciseWW, HintWW?, SolutionWW?)
                |
                    element stage {
                        Title?,
                        StatementExerciseWW,
                        HintWW?,
                        SolutionWW?
                    }+
                )
            }
        StatementExerciseWW =
            element statement {
                (
                    Paragraph |
                    WWInstruction |
                    Preformatted |
                    SideBySideNoCaption
                )+
            }
        WWMacros =
            element pg-macros {
                element macro-file {text}+
            }
        WWSetup =
            element setup {
                element pg-code {text}?
            }
        WWVariable =
            ## The WeBWorK "var" element appears in the RELAX-NG schema as a child of many elements, but almost always as a descendant of a "p" element or a "cell" element.  As an element that is only relevant for a WeBWorK problem, occurences of "var" must be within a "webwork" element.  A Schematron rule will check on these two situations.
            element var {
                (attribute name {text},
                attribute evaluator {text}?,
                attribute width {text}?,
                attribute category {
                                    "angle" | "decimal" | "exponent"
                                  | "formula" | "fraction" | "inequality"
                                  | "integer" | "interval" | "logarithm"
                                  | "limit" | "number" | "point"
                                  | "syntax" | "quantity" | "vector"
                                  }?,
                attribute form {"popup"|"buttons"|"none"}?) |
                (attribute form {"essay"},
                attribute width {text}?)
            }
        WWInstruction =
            element instruction {TextShort}
        HintWW =
            element hint {
                (
                    Paragraph |
                    Preformatted |
                    SideBySideNoCaption
                )+
            }
        SolutionWW =
            element solution {
                (
                    Paragraph |
                    Preformatted |
                    SideBySideNoCaption
                )+
            }
        </fragment>
    </section>

    <section>
        <title>Frequently Used</title>

        <p>Frequently used items, with no natural place to associate them.</p>


        <fragment xml:id="frequently-used">
        <fragment ref="statements" />
        <fragment ref="attribution" />
        <fragment ref="metadata" />
        </fragment>


        <fragment xml:id="statements">
        </fragment>

        <p>Used on the end of prefaces to <q>sign</q> them, and on block quotes.</p>

        <fragment xml:id="attribution">
        Attribution =
            element attribution {
                (TextLong | LongLine+)
            }
        </fragment>

        <p>There is a handful of elements which describe an item, but do not necessarily get processed as content.  Titles are an obvious example, and index entries are another.  Here we isolate a few common patterns to use for consistency throughout.</p>

        <p>Notes: <ul>
            <li>Language tags go on the root element to affect variants of names of objects, like theorems.</li>
            <li><attr>permid</attr> is part of managing editions, and is supplied by a script.  You should not be adding thse manually as an author.  (You do want to manually author <attr>xml:id</attr>.)</li>
            <li>The <c>xinlude</c> mechanism may pass language tgs down through the root element of included files to make them universally available.</li>
            <li>The <c>xinclude</c> mechanism inserts a <c>@xml:base</c> attribute on the root element of an included file.  So we allow this attribute on any element that allows a title.</li>
            <li>These are not unordered specifications since they contain several attributes, and we enforce a <c>title</c>, <c>subtitle</c>, <tag>shorttitle</tag>, <c>creator</c>, <c>caption</c>, <c>idx</c> order.</li>
            <li><c>MetaDataTarget</c> is for items that are targets of cross-references, but without even optional titles.  Since they will be knowled, they can appear in an index.  But without the potential to be titled, we do not set them up as possible root elements of a file to <c>xinclude</c>.</li>
            <li><c>MetaDataTitle</c> has a required <tag>title</tag>.</li>
            <li><c>MetaDataShortTitle</c> has a required <tag>title</tag>, and allows an optional <tag>shorttitle</tag>.</li>
            <li><c>MetaDataSubtitle</c> implicitly has a required <tag>title</tag>, and allows optional <tag>subtitle</tag> and <tag>shorttitle</tag>.</li>
            <li><c>MetaDataLinedTitle</c> and <c>MetaDataLinedSubtitle</c> are variants of the <c>Short</c> or <c>Subtitle</c> versions for use on larger divisions with <tag>line</tag> elements used to suggest line breaks in titles.</li>
            <li><c>MetaDataCaption</c> implicitly has an optional title.</li>
            <li>Titles may contain external references (<c>url</c>) or internal cross-references (<c>xref</c>), but implementers need not make them active (<ie />, they maybe text only), since titles are prone to migrating to other locations.</li>
        </ul></p>

        <fragment xml:id="metadata">
        UniqueID =
            attribute xml:id {text}
        PermanentID =
            attribute permid {text}
        Title =
            element title {TextLong}
        LinedTitle =
            element title {LongLine+}
        Subtitle =
            element subtitle {TextLong}
        LinedSubtitle =
            element subtitle {LongLine+}
        ShortTitle =
            element shorttitle {TextShort}
        Creator =
            element creator {TextShort}
        XMLBase = attribute xml:base {text}
        XMLLang = attribute xml:lang {text}
        MetaDataTarget =
            UniqueID?,
            PermanentID?,
            Index*
        MetaDataTitle =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            Title,
            Index*
        MetaDataShortTitle =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            Title,
            ShortTitle?,
            Index*
        MetaDataLinedTitle =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            (Title | LinedTitle),
            ShortTitle?,
            Index*
        MetaDataSubtitle =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            Title,
            Subtitle?,
            ShortTitle?,
            Index*
        MetaDataLinedSubtitle =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            (Title | LinedTitle),
            (Subtitle | LinedSubtitle)?,
            ShortTitle?,
            Index*
        MetaDataTitleOptional =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            Title?,
            Index*
        MetaDataShortTitleOptional =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            (Title, ShortTitle?)?,
            Index*
        MetaDataTitleCreatorOptional =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            Title?,
            Creator?,
            Index*
        MetaDataCaption =
            UniqueID?,
            PermanentID?,
            XMLBase?,
            XMLLang?,
            Title?,
            Caption,
            Index*
        </fragment>

    </section>

    <section>
        <title>Miscellaneous</title>

        <p>Provisional items, with uncertain futures.</p>

        <fragment xml:id="miscellaneous">
        </fragment>
    </section>

    <section>
        <title>Organizational Devices</title>

        <p>A <term>list generator</term> is a convenient device.  It can create appendices, or smaller table-of-contents at the start of divisions.</p>

        <p>Notation can be automatically generated.  We restrict its locations to appendices.</p>

        <fragment xml:id="listgenerator">
        ListGenerator =
            element list-of {
                attribute elements {text},
                attribute scope {text}?,
                attribute divisions {text}?,
                attribute empty {"yes" | "no"}?
            }
        NotationList =
            element notation-list {empty}
        </fragment>
    </section>

    <section>
        <title>Front Matter</title>

        <p>Articles and books have material at the start, which gets organized in interesting ways. <c>minilicense</c> is very restrictive, <c>shortlicense</c> allows references (<eg /> <init>URL</init>s).  <c>titlepage</c> is like a very small database<mdash />for HTML it migrates to the top of the page for the <c>frontmatter</c>, and for <latex /> it migrates to the half-title and title pages.  Since it generally makes no sense as the target of a cross-reference, <c>titlepagfe</c> does not allow an <c>@xml:id</c> attribute.</p>

        <fragment xml:id="frontmatter">
        ArticleFrontMatter =
            element frontmatter {
                MetaDataTitleOptional,
                TitlePage,
                Abstract?
            }
        BookFrontMatter = element frontmatter {
                MetaDataTitleOptional,
                TitlePage?,
                ColophonFront?,
                Biography*,
                Dedication?,
                Acknowledgement?,
                Preface*
            }
        TitlePage =
            element titlepage {
                (
                    (Author, Author*, Editor*)
                    |
                    (Editor, Editor*)
                ),
                Credit*,
                Date?
            }
        Author =
            element author {
                element personname {TextSimple},
                element department {TextSimple | ShortLine+}?,
                element institution {TextSimple | ShortLine+}?,
                element email {text}?
            }
        Editor =
            element editor {
                element personname {TextSimple},
                element department {TextSimple | ShortLine+}?,
                element institution {TextSimple | ShortLine+}?,
                element email {text}?
            }
        Credit =
            element credit {
                element title {TextLong},
                Author+
            }
        Date =
            element date {
                mixed {(Character | Generator)*}
            }
        Abstract =
            element abstract {
                MetaDataTitleOptional,
                BlockText+
            }
        ColophonFront =
            element colophon {
                MetaDataTarget,
                element credit {
                    element role {TextShort},
                    element entity {TextLong}
                }*,
                element edition {text}?,
                element website {
                    element name {TextShort},
                    element address {text}
                }?,
                element copyright {
                    element year {TextShort},
                    element holder {text},
                    element minilicense {TextShort}?,
                    element shortlicense {TextLong}?
                }?
            }
        Biography =
            element biography {
                MetaDataTitleOptional,
                (BlockStatementNoCaption | ParagraphsNoNumber | Commentary)+
            }
        Dedication =
            element dedication {
                MetaDataTitleOptional,
                (Paragraph|ParagraphLined)+
            }
        Acknowledgement =
            element acknowledgement {
                MetaDataTitleOptional,
                (BlockStatementNoCaption | ParagraphsNoNumber | Commentary)+
            }
        Preface =
            element preface {
                MetaDataTitleOptional,
                (
                    (
                        (BlockStatementNoCaption | ParagraphsNoNumber | Commentary)+,
                        Attribution*
                    )
                    |
                    (
                        (BlockStatementNoCaption | ParagraphsNoNumber | Commentary)*,
                        Contributors,
                        (BlockStatementNoCaption | ParagraphsNoNumber | Commentary)*
                    )
                )
            }
        </fragment>
    </section>

    <section>
        <title>Contributors</title>

        <p>A single <c>contributors</c> element may be placed into a <c>preface</c> and is a list of <c>contributor</c>.  It can be optionally preceded, or followed, by all the usual things that can go into any preface.  An AuthorByline is a special instance of acknowledging a contributor on a division.</p>

        <fragment xml:id="contributor">
        Contributor =
            element contributor {
                MetaDataTarget,
                element personname {TextSimple},
                element department {TextSimple}?,
                element institution {TextSimple}?,
                element location {TextSimple}?,
                element email {text}?
            }
        Contributors =
            element contributors {
                Contributor+
            }
        AuthorByline =
            element author {(TextSimple|Xref)}
        </fragment>
    </section>


    <section>
        <title>Back Matter</title>

        <p>Articles and books have material at the end, structured as a sequence of <c>appendix</c>.  A <c>solutions</c> division should be numbered and rendered as if it was one of the <c>appendix</c>, and so can mix-in in any order.</p>

        <fragment xml:id="backmatter">
        ArticleBackMatter =
            element backmatter {
                MetaDataTitleOptional,
                (ArticleAppendix|Solutions)*,
                References?,
                IndexDivision?,
                ColophonBack?
            }
        BookBackMatter =
            element backmatter {
                MetaDataTitleOptional,
                (BookAppendix|Solutions)*,
                References?,
                IndexDivision?,
                ColophonBack?
            }
        ColophonBack =
            element colophon {
                MetaDataTarget,
                (BlockText | SideBySideNoCaption | SideBySideGroupNoCaption)+
            }
        </fragment>
    </section>

    <section>
        <title>Document Information</title>

        <p>The <c>docinfo</c> section is like a small database for the document.</p>

        <fragment xml:id="docinfo">
        DocInfo =
            element docinfo {
                XMLBase?,
                XMLLang?,
                Configuration+
            }
        <fragment ref="brandlogo" />
        <fragment ref="latexpreamble" />
        <fragment ref="macros" />
        <fragment ref="cross-references" />
        <fragment ref="lateximagepreamble" />
        <fragment ref="initialism" />
        <fragment ref="feedback" />
        <fragment ref="rename" />
        <fragment ref="imagearchive" />
        <fragment ref="authorbiographylength" />
        <fragment ref="addins" />
        <fragment ref="numbering" />
        </fragment>

        <p>A nice icon near the top of an electronic version is a nice touch, and can link back to a project landing page.</p>

        <fragment xml:id="brandlogo">
        Configuration |=
            element brandlogo {
                attribute url {text}?,
                attribute source {text}
            }
        </fragment>

        <p>We add some items to the preamble for LaTeX.  A <c>package</c> needs to have an identical implementation, and be of the same name, as a version that exists for MathJax.</p>

        <fragment xml:id="latexpreamble">
        Configuration |=
            element latex-preamble {
                element package {text}*
            }
        </fragment>

        <p>Macros for <latex /> are shared across implementations.  This should move under some general <latex /> section, the name is too vague.</p>

        <fragment xml:id="macros">
        Configuration |=
            element macros {text}
        </fragment>

        <p>The style of text used in a cross-reference (the <c>xref</c> element) is contained in the source and uses the same per-item choices.</p>

        <fragment xml:id="cross-references">
        Configuration |=
            element
                cross-references {
                    attribute text { XrefTextStyle }
                }
        </fragment>

        <p>Images specified by <latex /> syntax sometimes need extra information in their preambles.</p>

        <fragment xml:id="lateximagepreamble">
        Configuration |=
            element latex-image-preamble {text}
        </fragment>

        <p>An initialism is a useful short version of a book title.</p>

        <fragment xml:id="initialism">
        Configuration |=
            element initialism {text}
        </fragment>

        <p>Online versions can request feedback via a URL for some form.  Maybe this should really be an <c>href</c> for consistency.  There should be a device to provide text to go with the link.</p>

        <fragment xml:id="feedback">
        Configuration |=
            element feedback {
                element url {text}
            }
        </fragment>

        <p>Some elements can be renamed.  This should be a rare event.  Since the content of this element can (optionally) be specified in  different languages, the <attr>xml:lang</attr> attribute is appropriate.<fn><url href="https://www.w3.org/International/questions/qa-when-xmllang"/></fn></p>

        <fragment xml:id="rename">
        Configuration |=
            element rename {
                attribute element {text},
                attribute xml:lang {text}?,
                text
            }
        </fragment>

        <p>Image archives have some global specification.  The <c>from</c> attribute gives a root for only working on a subtree of the document.  The content is a comma-separated list of file extensions.</p>

        <fragment xml:id="imagearchive">
        Configuration |=
            element images {
                element archive {
                    attribute from {text}?,
                    text
                }+
            }
        </fragment>

        <p>An author biography (or several) might be a paragraph or two each, or each one might be severalpages.  This style can be controlled.</p>

        <fragment xml:id="authorbiographylength">
        Configuration |=
            element author-biographies {
                attribute length {"short" | "long"}
            }
        </fragment>

        <p>Many aspects of numbering are configurable.  These choices affect the numbers printed, and so are an author's decision, and hence run with the source.</p>

        <fragment xml:id="numbering">
        Configuration |=
            element numbering {
                element division {
                    attribute part {"decorative" | "structural"}
                }?
            }
        </fragment>
    </section>

    <section>
        <title>Hierachical Structure</title>

        <p>We collect all the specifications, roughly in a top-down order, so the generated schema files have a rational ordering to them, even if the order presented here is different.</p>

        <fragment filename="pretext.rnc">
        grammar {
        <fragment ref="gross-structure" />
        <fragment ref="document-types" />
        <fragment ref="divisions" />
        <fragment ref="frontmatter" />
        <fragment ref="backmatter" />
        <fragment ref="paragraphs" />
        <fragment ref="universal" />
        <fragment ref="block" />
        <fragment ref="block-component" />
        <fragment ref="introduction-conclusion" />
        <fragment ref="objective-outcome" />
        <fragment ref="blockquote" />
        <fragment ref="verbatimdisplay" />
        <fragment ref="list" />
        <fragment ref="definition-like" />
        <fragment ref="theorem-like" />
        <fragment ref="axiom-like" />
        <fragment ref="example-like" />
        <fragment ref="project-like" />
        <fragment ref="remark-like" />
        <fragment ref="computation-like" />
        <fragment ref="aside" />
        <fragment ref="assemblage" />
        <fragment ref="table-figure" />
        <fragment ref="sidebyside" />
        <fragment ref="image" />
        <fragment ref="tabular" />
        <fragment ref="sage" />
        <fragment ref="interactive" />
        <fragment ref="audiovideo" />
        <fragment ref="exercise" />
        <fragment ref="poetry" />
        <fragment ref="bibliography" />
        <fragment ref="contributor" />
        <fragment ref="webwork" />
        <fragment ref="miscellaneous" />
        <fragment ref="frequently-used" />
        <fragment ref="paragraph" />
        <fragment ref="shorttext" />
        <fragment ref="footnote" />
        <fragment ref="index" />
        <fragment ref="reference" />
        <fragment ref="mathematics" />
        <fragment ref="verbatim" />
        <fragment ref="group" />
        <fragment ref="generator" />
        <fragment ref="siunit" />
        <fragment ref="character" />
        <fragment ref="listgenerator" />
        <fragment ref="bad-bank" />
        <fragment ref="docinfo" />
        }
        </fragment>
    </section>

    <section xml:id="badbank">
        <title>Bad Bank</title>

        <fragment xml:id="bad-bank">
        Demonstration = element demonstration {
            Title,
            Paragraph,
            Sage
        }
        </fragment>
    </section>

    <backmatter>
        <index>
            <title>Index</title>
            <index-list />
        </index>
    </backmatter>

    </article>
</pretext>
