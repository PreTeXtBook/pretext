#!/usr/bin/env python
# ********************************************************************
# Copyright 2010-2016 Robert A. Beezer
#
# This file is part of MathBook XML.
#
# MathBook XML is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 or version 3 of the
# License (at your option).
#
# MathBook XML is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MathBook XML.  If not, see <http://www.gnu.org/licenses/>.
# *********************************************************************

##############################################
#
#  Graphics Language Extraction and Processing
#
##############################################

def tikz_conversion(xml_source, xmlid_root, dest_dir, outformat):
    global config
    import tempfile, os, os.path, subprocess, shutil
    _verbose('converting tikz pictures from {} to {} graphics for placement in {}'.format(xml_source, outformat, dest_dir))
    dest_dir = sanitize_directory(dest_dir)
    tmp_dir = tempfile.mkdtemp()
    _debug("temporary directory: {}".format(tmp_dir))
    xslt_executable = get_executable(config,  'xslt')
    _debug("xslt executable: {}".format(xslt_executable))
    tex_executable = get_executable(config,  'tex')
    _debug("tex executable: {}".format(tex_executable))
    pdfsvg_executable = get_executable(config, 'pdfsvg')
    _debug("pdfsvg executable: {}".format(pdfsvg_executable))
    # http://stackoverflow.com/questions/11269575/how-to-hide-output-of-subprocess-in-python-2-7
    devnull = open(os.devnull, 'w')
    convert_cmd = [xslt_executable,
        '--stringparam', 'scratch', tmp_dir,
        '--stringparam', 'subtree', xmlid_root,
        '--xinclude',
        os.path.join(mbx_xsl_dir, 'extract-tikz.xsl'),
        xml_source
        ]
    _verbose("extracting tikz pictures from {}".format(xml_source))
    _debug("tikz conversion {}".format(convert_cmd))
    subprocess.call(convert_cmd)
    cwd = os.getcwd()
    os.chdir(tmp_dir)
    for tikzpic in os.listdir(tmp_dir):
        if outformat == 'source':
            shutil.copy2(tikzpic, dest_dir)
        else:
            filebase, _ = os.path.splitext(tikzpic)
            tikzpdf = "{}.pdf".format(filebase)
            tikzsvg = "{}.svg".format(filebase)
            latex_cmd = [tex_executable, tikzpic]
            _verbose("converting {} to {}".format(tikzpic, tikzpdf))
            subprocess.call(latex_cmd, stdout=devnull, stderr=subprocess.STDOUT)
            if outformat == 'svg':
                svg_cmd = [pdfsvg_executable, tikzpdf, tikzsvg]
                _verbose("converting {} to {}".format(tikzpdf, tikzsvg))
                subprocess.call(svg_cmd)
                shutil.copy2(tikzsvg, dest_dir)
            if outformat == 'pdf':
                shutil.copy2(tikzpdf, dest_dir)


def asymptote_conversion(xml_source, xmlid_root, dest_dir, outformat):
    global config
    import tempfile, os, os.path, subprocess, shutil, glob
    _verbose('converting Asymptote diagrams from {} to {} graphics for placement in {}'.format(xml_source, outformat.upper(), dest_dir))
    dest_dir = sanitize_directory(dest_dir)
    tmp_dir = tempfile.mkdtemp()
    _debug("temporary directory: {}".format(tmp_dir))
    xslt_executable = get_executable(config,  'xslt')
    _debug("xslt executable: {}".format(xslt_executable))
    asy_executable = get_executable(config,  'asy')
    _debug("asy executable: {}".format(asy_executable))
    extract_cmd = [xslt_executable,
        '--stringparam', 'scratch', tmp_dir,
        '--stringparam', 'subtree', xmlid_root,
        '--xinclude',
        os.path.join(mbx_xsl_dir, 'extract-asymptote.xsl'),
        xml_source
        ]
    _verbose("extracting Asymptote diagrams from {}".format(xml_source))
    subprocess.call(extract_cmd)
    cwd = os.getcwd()
    os.chdir(tmp_dir)
    devnull = open(os.devnull, 'w')
    for asydiagram in os.listdir(tmp_dir):
        if outformat == 'source':
            shutil.copy2(asydiagram, dest_dir)
        else:
            filebase, _ = os.path.splitext(asydiagram)
            asyout = "{}.{}".format(filebase, outformat)
            asypng = "{}_*.png".format(filebase)
            asy_cmd = [asy_executable, '-batchMask', '-outformat', outformat, asydiagram]
            _verbose("converting {} to {}".format(asydiagram, asyout))
            _debug("asymptote conversion {}".format(asy_cmd))
            subprocess.call(asy_cmd, stdout=devnull, stderr=subprocess.STDOUT)
            shutil.copy2(asyout, dest_dir)
            # Sometimes Asymptotes SVGs include multiple PNGs for colored regions
            for f in glob.glob(asypng):
                shutil.copy2(f, dest_dir)


def sage_conversion(xml_source, xmlid_root, dest_dir, outformat):
    global config
    import tempfile, os, os.path, subprocess, shutil, glob
    _verbose('converting Sage diagrams from {} to {} graphics for placement in {}'.format(xml_source, outformat.upper(), dest_dir))
    dest_dir = sanitize_directory(dest_dir)
    tmp_dir = tempfile.mkdtemp()
    _debug("temporary directory: {}".format(tmp_dir))
    xslt_executable = get_executable(config,  'xslt')
    _debug("xslt executable: {}".format(xslt_executable))
    sage_executable = get_executable(config,  'sage')
    _debug("sage executable: {}".format(sage_executable))
    extract_cmd = [xslt_executable,
        '--stringparam', 'scratch', tmp_dir,
        '--stringparam', 'subtree', xmlid_root,
        '--xinclude',
        os.path.join(mbx_xsl_dir, 'extract-sageplot.xsl'),
        xml_source
        ]
    _verbose("extracting Sage diagrams from {}".format(xml_source))
    subprocess.call(extract_cmd)
    cwd = os.getcwd()
    os.chdir(tmp_dir)
    devnull = open(os.devnull, 'w')
    for sageplot in os.listdir(tmp_dir):
        if outformat == 'source':
            shutil.copy2(sageplot, dest_dir)
        else:
            filebase, _ = os.path.splitext(sageplot)
            sageout = "{0}.{1}".format(filebase, outformat)
            sagepng = "{0}.png".format(filebase, outformat)
            sage_cmd = [sage_executable,  sageplot, outformat]
            _verbose("converting {} to {} (or {} for 3D)".format(sageplot, sageout, sagepng))
            _debug("sage conversion {}".format(sage_cmd))
            subprocess.call(sage_cmd, stdout=devnull, stderr=subprocess.STDOUT)
            # Sage makes PNGs for 3D
            for f in glob.glob(sageout):
                shutil.copy2(f, dest_dir)
            for f in glob.glob(sagepng):
                shutil.copy2(f, dest_dir)

def latex_image_conversion(xml_source, xmlid_root, data_dir, dest_dir, outformat):
    global config
    import tempfile, os, os.path, subprocess, shutil

    _verbose('converting latex-image pictures from {} to {} graphics for placement in {}'.format(xml_source, outformat, dest_dir))
    dest_dir = sanitize_directory(dest_dir)
    tmp_dir = tempfile.mkdtemp()
    _debug("temporary directory: {}".format(tmp_dir))
    xslt_executable = get_executable(config,  'xslt')
    _debug("xslt executable: {}".format(xslt_executable))
    # NB: next command uses relative paths, so no chdir(), etc beforehand
    if data_dir:
        copy_data_directory(xml_source, data_dir, tmp_dir)
    # http://stackoverflow.com/questions/11269575/how-to-hide-output-of-subprocess-in-python-2-7
    devnull = open(os.devnull, 'w')
    convert_cmd = [xslt_executable,
        '--stringparam', 'scratch', tmp_dir,
        '--stringparam', 'subtree', xmlid_root,
        '--xinclude',
        os.path.join(mbx_xsl_dir, 'extract-latex-image.xsl'),
        xml_source
        ]
    _verbose("extracting latex-image pictures from {}".format(xml_source))
    _debug("latex-image conversion {}".format(convert_cmd))
    subprocess.call(convert_cmd)
    cwd = os.getcwd()
    os.chdir(tmp_dir)
    # files *only*, from top-level
    files = list(filter(os.path.isfile, os.listdir(tmp_dir)))
    for latex_image in files:
        if outformat == 'source':
            shutil.copy2(latex_image, dest_dir)
        else:
            filebase, _ = os.path.splitext(latex_image)
            latex_image_pdf = "{}.pdf".format(filebase)
            latex_image_svg = "{}.svg".format(filebase)
            latex_image_png = "{}.png".format(filebase)
            latex_image_eps = "{}.eps".format(filebase)
            tex_executable = get_executable(config,  'tex')
            _debug("tex executable: {}".format(tex_executable))
            latex_cmd = [tex_executable, latex_image]
            _verbose("converting {} to {}".format(latex_image, latex_image_pdf))
            subprocess.call(latex_cmd, stdout=devnull, stderr=subprocess.STDOUT)
            if outformat == 'all':
                shutil.copy2(latex_image, dest_dir)
            if (outformat == 'pdf' or outformat == 'all'):
                shutil.copy2(latex_image_pdf, dest_dir)
            if (outformat == 'svg' or outformat == 'all'):
                pdfsvg_executable = get_executable(config, 'pdfsvg')
                _debug("pdfsvg executable: {}".format(pdfsvg_executable))
                svg_cmd = [pdfsvg_executable, latex_image_pdf, latex_image_svg]
                _verbose("converting {} to {}".format(latex_image_pdf, latex_image_svg))
                subprocess.call(svg_cmd)
                shutil.copy2(latex_image_svg, dest_dir)
            if (outformat == 'png' or outformat == 'all'):
                # create high-quality png, presumes "convert" executable
                pdfpng_executable = get_executable(config, 'pdfpng')
                _debug("pdfpng executable: {}".format(pdfpng_executable))
                png_cmd = [pdfpng_executable, "-density", "300",  latex_image_pdf, "-quality", "100", latex_image_png]
                _verbose("converting {} to {}".format(latex_image_pdf, latex_image_png))
                subprocess.call(png_cmd)
                shutil.copy2(latex_image_png, dest_dir)
            if (outformat == 'eps' or outformat == 'all'):
                pdfeps_executable = get_executable(config, 'pdfeps')
                _debug("pdfeps executable: {}".format(pdfeps_executable))
                eps_cmd = [pdfeps_executable, '-eps', latex_image_pdf, latex_image_eps]
                _verbose("converting {} to {}".format(latex_image_pdf, latex_image_eps))
                subprocess.call(eps_cmd)
                shutil.copy2(latex_image_eps, dest_dir)

###############################
#
#  WeBWorK to LaTeX on a Server
#
###############################

def webwork_to_tex(origin, xslt_exec, mbx_xsl_dir, xml_source, server_url, dest_dir):
    import subprocess, os.path, requests
    import re     # regular expressions for parsing
    from xml.sax.saxutils import escape    # sanitize string


    # execute XSL extraction for source problems
    # origin is a flag for where the problem is born
    #   'server' : lives on the server, only a URL is in MBX document
    #   'mbx'    : authored in MBX document (and has PG code for images)
    if origin == 'server':
        xsl_transform = 'extract-ww-tex-server.xsl'
        msg = 'analyzing source document for URLs of WeBWorK problems, to send to server for LaTeX version'
    elif origin == 'mbx':
        xsl_transform = 'extract-ww-tex-mbx.xsl'
        msg = 'analyzing source document for WeBWorK problems with PG images, to send to server for LaTeX version'
    else:
        raise ValueError("flag sent to webwork_to_tex() should be 'server' or 'tex', not '{}'".format(origin))
    extraction_xslt = os.path.join(mbx_xsl_dir, xsl_transform)
    cmd = [xslt_exec, '--xinclude', extraction_xslt, xml_source]
    _verbose(msg)
    try:
        problem_list = subprocess.check_output(cmd)
    except subprocess.CalledProcessError as e:
        root_cause = str(e)
        msg = 'xsltproc command failed, tried: "{}"\n'.format(' '.join(cmd))
        raise ValueError(msg + root_cause)
    # "run" an assignment for the list of triples of strings
    exec('problems = ' + problem_list)

    # verify destination exists
    sanitize_directory(dest_dir)

    # verify, construct problem format requestor
    server_url = sanitize_url(server_url)
    wwurl = server_url + "webwork2/html2xml"

    # using a "Session()" will pool connection information
    # since we always hit the same server, this should increase performance
    session = requests.Session()

    # dictionary of values for URL request, these are fixed for each problem
    # sourceFilePath and problemSeed are set below, on per-problem basis
    server_params = {
        'answersSubmitted': '0',
        'displayMode': 'tex',
        'courseID': 'anonymous',
        'userID': 'anonymous',
        'password': 'anonymous',
        'outputformat': 'simple'
    }

    # an entire web page comes back
    # these appear to exactly delimit what we want
    start_marker = re.compile('<div class="problem-content">')
    end_marker = re.compile('</div>')

    # WW server can react to a
    #   URL stored there already
    #   a base64 encoding of the problem
    if origin == 'server':
        ww_server_option = 'sourceFilePath'
    elif origin == 'mbx':
        ww_server_option = 'problemSource'

    # each problem is a triple created by the XSL transform
    # 0. "source", URL or base64 string (not URL encoded!)
    # 1. seed for randomness control
    # 2. the internal id string for coherence
    for problem in problems:
        source, seed, internal_id = problem
        server_params['problemSeed'] = seed
        server_params[ww_server_option] = source

        msg = "sending {} to server to save in {}: origin is '{}'"
        _verbose(msg.format(internal_id, dest_dir, origin))
        _debug('server-to-latex: {} {} {} {}'.format(source, wwurl, dest_dir, internal_id))

        # Ready, go out on the wire
        try:
            response = session.get(wwurl, params=server_params, verify=False)
        except requests.exceptions.RequestException as e:
            root_cause = str(e)
            msg = "There was a problem collecting a problem,\n Server: {}\nRequest Parameters: {}\n"
            raise ValueError(msg.format(wwurl, server_params) + root_cause)
        # Obtained, this is it
        # Could mine the title and other things
        content = response.text
        # strip out actual TeX code between markers
        start = start_marker.split(content, maxsplit=1)
        content = start[1]
        end = end_marker.split(content, maxsplit=1)
        tex_only = end[0]

        # There is a problem header we'd prefer not to see
        # When enmeshed in some TeX macros, we need remove it
        # Pattern is based on:
        #
        # {\bf 13. {\footnotesize (1 point) \path|Library/....pg|}}\newline
        #
        header_pattern = re.compile(r'{\\bf.*\\path\|.*\|}}\\newline')
        head_match = header_pattern.search(tex_only)
        if head_match:
            tex_only = tex_only.replace(head_match.group(), '%mbx script removed problem header\n')

        # Some tex that causes compilation errors
        # Ends with comment, so no extra newline inserted
        tex_only = tex_only.replace('\\vadjust{\kern3pt}%', 
                                    '\\leavevmode\\vadjust{\kern3pt}% mbx script adjusted')

        # need to loop through content looking for images with pattern:
        #
        #   \includegraphics[<width-spec>]{(base-graphic-filename).(file-extension)}
        #
        graphics_pattern = re.compile(r'\\includegraphics\[[^\]]*\]{([^\.]*)\.([^}]*)}')

        # replace filenames, download images with new filenames
        count = 0
        for match in re.finditer(graphics_pattern, tex_only):
            count += 1
            ww_basename = match.group(1)
            file_extension = '.' + match.group(2)
            ww_filename = ww_basename + file_extension
            # rename, eg, webwork-tex/webwork-5-image-3.png
            mbx_basename =  internal_id + '-image-' + str(count)
            mbx_filename = mbx_basename + file_extension
            # URL of image on server starts two steps down
            image_url = server_url + ww_filename.replace('/var/www/', '')
            # modify LaTeX problem source to include local versions
            tex_only = tex_only.replace(ww_filename, 'webwork-tex/' + mbx_filename)
            # download actual image files
            # http://stackoverflow.com/questions/13137817/how-to-download-image-using-requests
            try:
                response = session.get(image_url, verify=False)
            except requests.exceptions.RequestException as e:
                root_cause = str(e)
                msg = "There was a problem downloading an image file,\n URL: {}\n"
                raise ValueError(msg.format(image_url) + root_cause)
            # and save the image itself
            try:
                image_file = open(os.path.join(dest_dir, mbx_filename), 'wb')
                image_file.write(response.content)
                image_file.close()
            except Exception as e:
                root_cause = str(e)
                msg = "There was a problem saving an image file,\n Filename: {}\n"
                raise ValueError(os.path.join(dest_dir, mbx_filename) + root_cause)

        # various strings and patterns for XML-ification
        # we pass the seed along for reliability/accuracy
        problem_start = r'<webwork-tex seed="{}">'.format(seed)
        problem_end = r'</webwork-tex>'

        preamble_end_pattern = re.compile(r'%%% END beginproblem\(\)')
        preamble_start = r'<preamble>'
        preamble_end = r'</preamble>'

        statement_start = r'<statement>'
        statement_end = r'</statement>'

        solution_begin_pattern = re.compile(r'%%% BEGIN SOLUTION')
        solution_end_pattern = re.compile(r'%%% END SOLUTION')
        solution_start = r'<solution>'
        solution_end = r'</solution>'

        hint_begin_pattern = re.compile(r'%%% BEGIN HINT')
        hint_end_pattern = re.compile(r'%%% END HINT')
        hint_start = r'<hint>'
        hint_end = r'</hint>'

        start_pattern = re.compile(r'<preamble>|<solution>|<hint>')
        end_pattern = re.compile(r'<\/preamble>|<\/solution>|<\/hint>')

        # the right time to escape problematic XML characters, <, >, &
        # https://wiki.python.org/moin/EscapingXml
        tex_only = escape(tex_only)

        # is end of preamble marked?
        # should only happen once
        match = preamble_end_pattern.search(tex_only)
        if match:
            tex_only = preamble_start + '\n' + tex_only
            tex_only = preamble_end_pattern.sub(preamble_end, tex_only, count=1)
        # straightup replacements for solutions, hints
        tex_only = solution_begin_pattern.sub(solution_start, tex_only)
        tex_only = solution_end_pattern.sub(solution_end, tex_only)
        tex_only = hint_begin_pattern.sub(hint_start, tex_only)
        tex_only = hint_end_pattern.sub(hint_end, tex_only)

        # problem statements appear as "text()"
        # boolean "balanced" means previous line ends an XML element
        xml_lines = [problem_start]
        balanced = True
        for line in iter(tex_only.splitlines()):
            # throw out blank lines between XML elements
            if balanced and line == '':
                pass
            # if a group does not start, then begin problem statement
            elif balanced:
                if not(start_pattern.search(line)):
                    xml_lines.append(statement_start)
                    balanced = False
                else:
                    balanced = False
                xml_lines.append(line)
            # if we encounter a start while unbalanced, close statement
            # if we hit the end of an element, we flip to balanced
            elif not(balanced):
                if start_pattern.search(line):
                    xml_lines.append(statement_end)
                    balanced = False  # matching start line is reproduced
                elif end_pattern.search(line):
                    balanced = True
                xml_lines.append(line)
        xml_lines.append(problem_end)

        # place modified LaTeX as XML in a file in destination directory
        include_file_name = os.path.join(dest_dir, internal_id + ".xml")
        try:
            include_file = open(include_file_name, 'w')
            include_file.write('\n'.join(xml_lines))
            include_file.close()
        except Exception as e:
            root_cause = str(e)
            msg = "There was a problem writing a problem to the file: {}\n"
            raise ValueError(msg.format(include_file_name) + root_cause)


#######################################
#
# Sage Worksheet Creation and Packaging
#
#######################################

# Conversion object adapted/simplified from  tex2sws  project (c. 2010)

# TODO: patrol normalized paths for Windows compatibility (universally)
# TODO: Cleanup temporay directory if not -vv

class MathBookXMLtoSWS(object):

    def __init__(self, xslt_exec, mbx_dir, xml_file, sws_file):
        r"""
        Configure the working environment for a conversion.

        INPUT:

        - ``xslt_exec`` - XSLT executable

        - ``mbx_dir`` - root of MBX distribution

        - ``xml_file`` - a MathBook XML file to convert
          to a Sage Notebook file

        - ``sws_file`` - final name/location of Sage Notebook file

        OUTPUT:
        An sws format file for the Sage Notebook reflecting the document.
        """
        import os.path   # join
        import tempfile  # mkdtemp

        _verbose('converting {} to {}'.format(xml_file, sws_file))

        if not xml_file:
            raise ValueError('an XML file for input must be specified')
        if not sws_file:
            raise ValueError('an SWS file for output must be specified')

        _debug('MBX, XML, SWS locations: {}, {}, {}'.format(mbx_dir, xml_file, sws_file))

        # Record locations for use later in the class
        # Prior to making/using temporary directory
        self._xml_file = os.path.abspath(xml_file)
        self._sws_file = os.path.abspath(sws_file)
        self._xsltproc_exec = xslt_exec
        self._mathbook_xslt = os.path.join(mbx_dir, 'xsl/mathbook-sagenb.xsl')
        # Whole book as Sage worksheets
        # self._mathbook_xslt = '/home/rob/books/aata/aata/xsl/aata-sagenb.xsl'
        # Just exercises as Sage worksheets
        # self._mathbook_xslt = '/home/rob/books/aata/aata/xsl/aata-sage-exercises.xsl'
        self._source_dir = get_source_path(self._xml_file)
        self._tmp_dir = tempfile.mkdtemp()
        _debug('xslt exec, MB XSL, source-dir, temp-dir: {}, {}, {}, {}'.format(self._xsltproc_exec, self._mathbook_xslt, self._source_dir, self._tmp_dir))

    def _process_xml(self):
        import os
        import subprocess

        _verbose('extracting files and assets from XML file via XSLT')
        os.chdir(self._tmp_dir)
        devnull = open(os.devnull, 'w')
        content_cmd = [self._xsltproc_exec, '--xinclude',
                       '--stringparam', 'purpose', 'files',
                       self._mathbook_xslt, self._xml_file
                      ]
        subprocess.call(content_cmd)
        info_cmd = [self._xsltproc_exec, '--xinclude',
                       '--stringparam', 'purpose', 'info',
                       self._mathbook_xslt, self._xml_file
                      ]
        # info will be a string that begins with "manifest = "
        # A list, each element a pair
        # first a filename, then a list of included files
        info = subprocess.check_output(info_cmd)
        exec(info)
        _debug('Manifest, information list: {}'.format(manifest))
        return manifest


    def _create_single_sws(self, html_file, title, assets):
        r"""
        Create a single Sage worksheet in SWS format.

        INPUTS:

        - ``html_file`` - name of an HTML file of "raw" content

        - ``title`` - string for title

        - ``assets`` - a list of (image) files to place
          in the worksheet data directory

        This routine creates a worksheet "from scratch" using just Python
        and none of the notebook code.  This makes for quicker startup times
        and the ability to run without Sage present.

        OUTPUT:  This routine places a Sage worksheet in the main
        temporary directory.  Later we determine if there are more.
        """
        import time  # for last change in pickled worksheet info
        import tempfile
        import tarfile
        import pickle
        import os
        import os.path  # join, split, splitext
        import glob     # find PNG's of SVg's

        # Make a generic worksheet configuration as a Python dictionary
        basic = {
            'name': title,
            'system': 'sage',
            'owner': 'admin',
            'last_change': ('admin', time.time()),
            }

        basename, _ = os.path.splitext(html_file)
        base_dir = 'sage_worksheet'
        data_dir = 'data'

        # Build sws as a tar file
        sws_file = '{}.sws'.format(basename)
        T = tarfile.open(sws_file, 'w:bz2')

        # Pickle configuration file
        # Write into temp file, add to sws file
        fd, configfile =  tempfile.mkstemp()
        config = pickle.dumps(basic)
        open(configfile, 'w').write(config)
        T.add(configfile, os.path.join(base_dir, 'worksheet_conf.pickle'))
        os.unlink(configfile)
        os.fdopen(fd,'w').close()

        # Worksheet file, new style (.html suffix)
        _debug('Making "worksheet.html" in sws archive from {}'.format(html_file))
        T.add(html_file, arcname=os.path.join(base_dir, 'worksheet.html'))

        # Worksheet file, old style (prepend two-line header, .txt suffix)
        _debug('Making "worksheet.txt" in sws archive from {}'.format(html_file))
        header = '{}\nsystem: sage\n'.format(title)
        original = open(html_file, 'r').read()
        fd, oldstyle =  tempfile.mkstemp()
        open(oldstyle, 'w').write(header + original)
        T.add(oldstyle, arcname=os.path.join(base_dir, 'worksheet.txt'))
        os.unlink(oldstyle)
        os.fdopen(fd,'w').close()

        # add various necessary files from asset list
        for afile in assets:
            source = os.path.join(self._source_dir, afile)
            # XSLT produces SVG file names for generated plots
            # PNG is the fallback, esp for <sageplot>
            if not(os.path.isfile(source)):
                source = source[:-3] + 'png'
                afile = afile[:-3] + 'png'
            dest = os.path.join(base_dir, data_dir, afile)
            _debug('adding {} to sws archive as {}'.format(source, dest))
            T.add(source, arcname=dest)
            # look for Asymptote SVG's which include similarly-named PNG's
            base, ext = os.path.splitext(afile)
            if ext in ['.svg', '.SVG']:
                pattern = os.path.join(self._source_dir, base + '_*.png')
                for f in glob.glob(pattern):
                    _, includedfile = os.path.split(f)
                    dest = os.path.join(base_dir, data_dir, base + '_*.png')
                    T.add(f, arcname=dest)

        T.close()
        return sws_file

    def _package_worksheets(self, worksheets):
        r"""
        Rename/move single worksheet, or zip a collection.

        INPUTS:

        - ``worksheets`` - a list of worsheet file names, no paths

        OUTPUT:  One SWS file, or several collected in a zip archive.
        """
        import os.path # splitext
        import shutil  # copy2
        import zipfile # Zipfile

        destination = self._sws_file  # perhaps really a zip file
        _verbose('Manufacturing final notebook-compatible file: {}'.format(destination))
        _debug('Packaging following SWS files: {}'.format(worksheets))

        # Sanity checks on worksheets, filename
        if len(worksheets) == 0:
            raise ValueError('XSLT transform produced no output, check configuration')
        single = (len(worksheets) == 1)
        _, ext = os.path.splitext(destination)
        if single:
            if not(ext in ['.sws', '.SWS']):
                msg = 'creating a single worksheet, filename should end in ".sws", not "{}"'
                raise ValueError(msg.format(ext))
        else:
            if not(ext in ['.zip', '.ZIP']):
                msg = 'creating multiple worksheets, filename should end in ".zip", not "{}"'
                raise ValueError(msg.format(ext))
        if single:
            # Singe worksheet: copy from temp/working to final resting place
            # Prepend temp directory
            sws = os.path.join(self._tmp_dir, worksheets[0])
            shutil.copy2(sws, destination)
        else:
            # Multiple worksheets: manufactured in final resting place
            Z = zipfile.ZipFile(destination, 'w')
            for afile in worksheets:
                Z.write(afile)
            Z.close()


    def convert(self):
        r"""
        The one public method.
        """
        import subprocess
        import os.path

        worksheets = []
        info = self._process_xml()
        # Creating early portions of the document later in time
        # provides later timestamps and places them lower in the
        # time-sorted worksheet-list of the Sage notebook interface
        for afile in reversed(info):
            _verbose('Converting {} to an SWS file'.format(afile[0]))
            sws_file = self._create_single_sws(afile[0], afile[1], afile[2])
            worksheets.append(sws_file)
        self._package_worksheets(worksheets)


###################
#
# Utility Functions
#
###################

def _verbose(msg):
    """Write a message to the console on program progress"""
    global args
    if args.verbose >= 1:
        print('MBX: {}'.format(msg))


def _debug(msg):
    """Write a message to the console with some raw information"""
    global args
    if args.verbose >= 2:
        print('MBX-DEBUG: {}'.format(msg))


def get_mbx_path():
    """Returns path of root of MBX distribution"""
    import sys, os.path
    _verbose("discovering MBX root directory from mbx script location")
    # full path to script itself
    mbx_path = os.path.abspath(sys.argv[0])
    # split "mbx" executable off path
    script_dir, _ = os.path.split(mbx_path)
    # split "script" path off executable
    distribution_dir, _ = os.path.split(script_dir)
    _verbose("MBX distribution root directory: {}".format(distribution_dir))
    return distribution_dir


def get_source_path(source_file):
    """Returns path of source XML file"""
    import sys, os.path
    _verbose("discovering source directory from source location")
    # split path off filename
    source_dir, _ = os.path.split(source_file)
    return os.path.normpath(source_dir)

def get_executable(config, exec_name):
    "Queries configuration file for executable name, verifies existence in Unix"
    import os
    import platform
    import subprocess

    # http://stackoverflow.com/questions/11210104/check-if-a-program-exists-from-a-python-script
    # suggests  where.exe  as Windows equivalent (post Windows Server 2003)
    # which  = 'where.exe' if platform.system() == 'Windows' else 'which'

    # get the name, but then see if it really, really works
    _debug('locating "{}" in [executables] section of configuration file'.format(exec_name))
    config_name = config.get('executables', exec_name)

    devnull = open(os.devnull, 'w')
    try:
        result_code = subprocess.call(['which', config_name], stdout=devnull, stderr=subprocess.STDOUT)
    except OSError:
        print('MBX:WARNING: executable existence-checking was not performed (e.g. on Windows)')
        result_code = 0  # perhaps a lie on Windows
    if result_code != 0:
        error_message = '\n'.join([
                        'cannot locate executable with configuration name "{}" as command "{}"',
                        'Edit the configuration file and/or install the necessary program'])
        raise OSError(error_message.format(exec_name, config_name))
    _debug("{} executable: {}".format(exec_name, config_name))
    return config_name

def get_cli_arguments():
    """Return the CLI arguments in parser object"""
    import argparse
    parser = argparse.ArgumentParser(description='MathBook XML utility script', formatter_class=argparse.RawTextHelpFormatter)

    verbose_help = '\n'.join(["verbosity of information on progress of the program",
                              "  -v  is actions being performed",
                              "  -vv is some additional raw debugging information"])
    parser.add_argument('-v', '--verbose', help=verbose_help, action="count")

    component_info = [
        ('tikz', 'tikz pictures'),
        ('asy', 'Asymptote diagrams'),
        ('sageplot', 'Sage graphics'),
        ('latex-image', 'LaTeX pictures'),
        ('webwork-tex', 'WeBWorK server problems as LaTeX'),
        ('all', 'Complete document'),
    ]
    component_help = 'Possible components are:\n' + '\n'.join(['  {} - {}'.format(info[0], info[1]) for info in component_info])
    parser.add_argument('-c', '--component', help=component_help, action="store", dest="component")

    format_info = [
        ('svg', 'Scalable Vector Graphicsfile(s)'),
        ('pdf', 'Portable Document Format file(s)'),
        ('png', 'Portable Network Graphics file(s)'),
        ('eps', 'Encapsulated Post Script file(s)'),
        ('source', 'Standalone source files'),
        ('latex', 'LaTeX source file'),
        ('html', 'HyperText Markup Language (web pages)'),
        ('sagenb', 'Sage *.sws archive of worksheets'),
        ('all', 'All available output formats'),
    ]
    format_help = 'Output formats are:\n' + '\n'.join(['  {} - {}'.format(info[0], info[1]) for info in format_info])
    parser.add_argument('-f', '--format', help=format_help, action="store", dest='format')

    # default to an empty string, which signals root to XSL stylesheet
    parser.add_argument('-r', '--restrict', help='restrict to subtree rooted at element with specified xml:id',
                         action="store", dest='xmlid', default='')

    parser.add_argument('-s', '--server', help='base URL for server (webwork-tex only)', action="store", dest='server')

    parser.add_argument('-i', '--include', help='external data directory, relative to source, latex-image only', action="store", dest='data_dir')
    parser.add_argument('-o', '--output', help='file for output', action="store", dest='out')
    parser.add_argument('-d', '--directory', help='directory for output', action="store", dest='dir')

    parser.add_argument('xml_file', help='MathBook XML source file with content', action="store")

    return parser.parse_args()


def sanitize_directory(dir):
    """Verify directory name, or raise error"""
    # Use with os.path.join, and do not sweat separator
    import os.path
    _verbose('verifying directory: {}'.format(dir))
    if not(os.path.isdir(dir)):
        raise ValueError('directory {} does not exist'.format(dir))
    return dir

# Certificate checking is buggy, exception raised is malformed
# 2015/10/07 Turned off verification in three places
# Command line warning can be disabled, requests.packages.urllib3.disable_warnings()
def sanitize_url(url):
    """Verify a server address, append a slash"""
    _verbose('validating, cleaning server URL: {}'.format(url))
    import requests
    try:
        requests.get(url, verify=False)
    except requests.exceptions.RequestException as e:
        root_cause = str(e)
        msg = "There was a problem with the server URL, {}\n".format(url)
        raise ValueError(msg + root_cause)
    # We expect relative paths to locations on the server
    # So we add a slash if there is not one already
    if url[-1] != "/":
        url = url + "/"
    return url

def get_config_info(script_dir, user_dir):
    """Return configuation in object for querying"""
    import sys,os.path
    config_filename = "mbx.cfg"
    default_config_file = os.path.join(script_dir, config_filename)
    user_config_file = os.path.join(user_dir, config_filename)
    config_file_list = [default_config_file, user_config_file]
    # ConfigParser was renamed to configparser in Python 3
    try:
        import configparser
    except ImportError:
        import ConfigParser as configparser
    config = configparser.SafeConfigParser()
    _verbose("parsing configuration files: {}".format(config_file_list))
    files_read = config.read(config_file_list)
    _debug("configuration files used/read: {}".format(files_read))
    if not(user_config_file in files_read):
        msg = "using default configuration only, custom configuration file not used at {}"
        _verbose(msg.format(user_config_file))
    return config

def copy_data_directory(source_file, data_dir, tmp_dir):
    """Stage directory from CLI argument into the working directory"""
    import os.path, shutil
    _verbose("formulating data directory location")
    source_full_path, _ = os.path.split(os.path.abspath(source_file))
    data_full_path = sanitize_directory(os.path.join(source_full_path, data_dir))
    data_last_step = os.path.basename(os.path.normpath(data_full_path))
    destination_root = os.path.join(tmp_dir, data_last_step)
    _debug("copying data directory {} to working location {}".format(data_full_path, destination_root))
    shutil.copytree(data_full_path, destination_root)

######
#
# Main
#
######

# Parse command line
# Deduce some paths
# Read configuration file
# Switch on command line

import os.path

# grab command line arguments
args = get_cli_arguments()
_debug("CLI args {}".format(vars(args)))

# directory locations relative to MathBook XML installation
mbx_dir = get_mbx_path()
mbx_xsl_dir = os.path.join(mbx_dir, "xsl")
mbx_script_dir = os.path.join(mbx_dir, "script")
mbx_user_dir = os.path.join(mbx_dir, "user")
_debug("xsl, script, user dirs: {}".format([mbx_xsl_dir, mbx_script_dir, mbx_user_dir]))

# directory location for outputs
output_dir = os.path.abspath(args.dir)
_debug("output dir: {}".format(output_dir))

config = get_config_info(mbx_script_dir, mbx_user_dir)

if args.component == 'tikz':
    if args.format == 'pdf':
        tikz_conversion(args.xml_file, args.xmlid, output_dir, 'pdf')
    elif args.format == 'svg':
        tikz_conversion(args.xml_file, args.xmlid, output_dir, 'svg')
    elif args.format == 'source':
        tikz_conversion(args.xml_file, args.xmlid, output_dir, 'source')
    else:
        raise NotImplementedError('cannot make TikZ pictures in "{}" format'.format(args.format))
elif args.component == 'asy':
    if args.format == 'pdf':
        asymptote_conversion(args.xml_file, args.xmlid, output_dir, 'pdf')
    elif args.format == 'svg':
        asymptote_conversion(args.xml_file, args.xmlid, output_dir, 'svg')
    elif args.format == 'source':
        asymptote_conversion(args.xml_file, args.xmlid, output_dir, 'source')
    else:
        raise NotImplementedError('cannot make Asymptote diagrams in "{}" format'.format(args.format))
elif args.component == 'sageplot':
    if args.format == 'pdf':
        sage_conversion(args.xml_file, args.xmlid, output_dir, 'pdf')
    elif args.format == 'svg':
        sage_conversion(args.xml_file, args.xmlid, output_dir, 'svg')
    elif args.format == 'source':
        sage_conversion(args.xml_file, args.xmlid, output_dir, 'source')
    else:
        raise NotImplementedError('cannot make Sage graphics in "{}" format'.format(args.format))
elif args.component == 'latex-image':
    if args.format == 'pdf':
        latex_image_conversion(args.xml_file, args.xmlid, args.data_dir, output_dir, 'pdf')
    elif args.format == 'svg':
        latex_image_conversion(args.xml_file, args.xmlid, args.data_dir, output_dir, 'svg')
    elif args.format == 'source':
        latex_image_conversion(args.xml_file, args.xmlid, args.data_dir, output_dir, 'source')
    elif args.format == 'png':
        latex_image_conversion(args.xml_file, args.xmlid, args.data_dir, output_dir, 'png')
    elif args.format == 'eps':
        latex_image_conversion(args.xml_file, args.xmlid, args.data_dir, output_dir, 'eps')
    elif args.format == 'all':
        latex_image_conversion(args.xml_file, args.xmlid, args.data_dir, output_dir, 'all')
    else:
        raise NotImplementedError('cannot make LaTeX pictures in "{}" format'.format(args.format))
elif args.component == 'webwork-tex':
    xslt_executable = get_executable(config,  'xslt')
    _debug("xslt executable command: {}".format(xslt_executable))
    webwork_to_tex('server', xslt_executable, mbx_xsl_dir, args.xml_file, args.server, output_dir)
    webwork_to_tex('mbx',    xslt_executable, mbx_xsl_dir, args.xml_file, args.server, output_dir)
elif args.component == 'all':
    if args.format == 'sagenb':
        # initialize  the converter
        xslt_executable = get_executable(config,  'xslt')
        _debug("xslt executable command: {}".format(xslt_executable))
        m2s = MathBookXMLtoSWS(xslt_exec=xslt_executable, mbx_dir=mbx_dir, xml_file=args.xml_file, sws_file=args.out)
        # Do the conversion
        m2s.convert()
    elif args.format == 'html':
        raise NotImplementedError("conversion to HTML version not integrated yet, use command line")
    elif args.format == 'latex':
        raise NotImplementedError("conversion to LaTeX version not integrated yet, use command line")
    else:
        raise NotImplementedError('cannot make entire document in "{}" format'.format(args.format))
else:
    raise ValueError('the "{}" component is not a conversion option'.format(args.component))
